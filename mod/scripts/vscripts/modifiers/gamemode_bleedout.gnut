untyped // for player.GiveExtraWeaponMod()
// WIP: Health limited incap shield( done by using a constant shield ), Downed Fake Player
/*
WARNING BY NESSIE( fixed by Bleedout_PlayerMovementLimiter() ): 
Bleedout_DiableWallrunAndDoubleJump() and Bleedout_EnableWallrunAndDoubleJump()
existing, which will do a "OnClassChange" after being downed or revived, please notice!
maybe when bleeding player is wallrunning we FreezeControl could be better? like SlidePrevention()
*/
global function Modded_Gamemode_Bleedout_Init

global function Bleedout_HealthRegenThink
global function Bleedout_SetHealthRegenRate

const asset BLEEDOUT_EXECUTION_HITBOX_MODEL = $"models/weapons/bullets/mgl_grenade.mdl"

// modified settings!
global function Bleedout_EnableExecutingBleedingPlayer
global function Bleedout_SetProtectionDuration
global function Bleedout_SetIncapShieldHealth
global function Bleedout_SetIncapShieldInvulnerable

const float BLEEDOUT_PROTECTION_DURATION = 1.05
const int BLEEDOUT_INCAP_SHIELD_MAX_HEALTH = 350

struct IncapShieldStruct
{
	entity vortexSphere
	entity shieldWallFX1P
}

// things below should be in riff
/*
riff_player_bleedout 1
player_bleedout_forceHolster 1
player_bleedout_forceDeathOnTeamBleedout 0
player_bleedout_bleedoutTime 20
player_bleedout_firstAidTime 2
player_bleedout_firstAidTimeSelf 6
player_bleedout_firstAidHealPercent 0.4
player_bleedout_aiBleedingPlayerMissChance 0.25

// abandoned
const float GAMEMODE_BLEEDOUT_TIME = 15
const float GAMEMODE_FIRSTAID_TIME = 2
const float GAMEMODE_FIRSTAID_TIME_SELF = 6
const float GAMEMODE_FIRSTAID_HEAL_PERCENT = 0.4
const float GAMEMODE_AI_BLEEDING_PLAYER_MISS_CHANCE = 0.5
const bool GAMEMODE_FORCE_WEAPON_HOLSTER = true
const bool GAMEMODE_DEATH_ON_TEAM_BLEEDOUT = false
*/
// fake apex loadouts
const bool BLEEDOUT_MODE_ENABLE_SECOND_LOADOUT = false

const float BLEEDOUT_MODE_SHIELD_BATTERY_USETIME = 2.1 // remember try to avoid sound issue
const float BLEEDOUT_MODE_AMPED_SHIELD_BATTERY_USETIME = 7.0
const int BLEEDOUT_MODE_SHIELD_BATTERY_REGEN_AMOUNT = 100
const int BLEEDOUT_MODE_REVIVING_FRIENDLY_SHIELD_REWARD = 80
const int BLEEDOUT_MODE_EXECUTION_SHIELD_REWARD = 80
const int BLEEDOUT_MODE_AMPED_SHIELD_BATTERY_REGEN_AMOUNT = 300

const int BLEEDOUT_MODE_HEALTH = 125
const int BLEEDOUT_MODE_DOWNED_HEALTH = 100
const int BLEEDOUT_MODE_SHIELD_HEALTH = 100

const float BLEEDOUT_MODE_ELIMINATE_PILOT_EARNED_VALUE = 0.1
const float BLEEDOUT_MODE_ELIMINATE_PILOT_OWNED_VALUE = 0.3
// only earn values if you're assisting
const float BLEEDOUT_MODE_PILOT_ASSIST_EARNED_VALUE = 0.3
const float BLEEDOUT_MODE_PILOT_ASSIST_OWNED_VALUE = 0.0

struct
{
    table< string, bool > useFakeApexLoadout // player's uid, don't know whether to use

    // modified variable
	bool executingBleedingEnabled = false
	float bleedoutHealthRegenRate = 4.0
	float bleedoutHealthRegenDelay = 4.0
	float protectionDuration = BLEEDOUT_PROTECTION_DURATION
	//table<entity, string> playerSavedTitle
	//table<entity, int> incapShieldHealthTable // abandoned
	int incapShieldMaxHealth = BLEEDOUT_INCAP_SHIELD_MAX_HEALTH
	//table<entity, IncapShieldStruct> playerIncapShieldTable // no need to use 1p things
	table<entity, entity> playerIncapShieldTable
	bool invulnerableIncapShield
	table<entity, entity> bleedoutFakePlayers
} file

void function Modded_Gamemode_Bleedout_Init()
{
	if ( GetCurrentPlaylistVarInt( "modded_bleedout", 0 ) == 0 )
		return
    PrecacheParticleSystem( $"death_pinkmist_LG_nochunk" )
	PrecacheParticleSystem( $"xo_damage_exp_2" )
	
    Bleedout_EnableExecutingBleedingPlayer( true ) // funny
	//Bleedout_SetIncapShieldInvulnerable( true ) // op
	//Bleedout_AllowInterruptSelfRes( false ) // meaning you can choose weather allow teammate revive you, complicated
	SetShouldPlayerStartBleedoutFunc( GamemodeBleedout_PlayerDownedCheck ) // using this will also check shield health
	Bleedout_SetBleedoutDofEnabled( false ) // disables annoying dof
	Bleedout_SetDownedGracePeriodEnabled( false ) // disable annoying sound

	MeleeSyncedNPC_EnableAll_Init() // if you choose...
	Melee_AlwaysDoRandomSyncedMelee( true ) // funny modifier
	
    SetBurnCardAllBattery( true ) // from _burnmeter.gnut
	
    SetPlayerDeathsHidden( true ) // no sounds for deaths, and won't count deaths by default
    SetWeaponDropsEnabled( false ) // bleedout uses USE so much, don't let players drop weapons
    ScoreEvent_ForceUsePilotEliminateEvent( true ) // from _score.nut, do special "Eliminate Pilot" Score event
    
    // from pilot_shield_battery.gnut, shield battery main mechanic
    SetPilotBatteryUsageAllowed( true )
    SetShieldBatteryInputOverwritesBoost( true )
    SetShieldBatteryUseTime( BLEEDOUT_MODE_SHIELD_BATTERY_USETIME, BLEEDOUT_MODE_AMPED_SHIELD_BATTERY_USETIME )
    SetShieldBatteryRegenAmount( BLEEDOUT_MODE_SHIELD_BATTERY_REGEN_AMOUNT, BLEEDOUT_MODE_AMPED_SHIELD_BATTERY_REGEN_AMOUNT )

    // don't make the intro annoying
    ClassicMP_SetLevelIntro( ClassicMP_ShorterDropshipIntro_Setup, DROPSHIP_INTRO_LENGTH_SHORTER )
	ClassicMP_ForceDisableEpilogue( true ) // temp

    Bleedout_AddCallback_OnPlayerStartBleedout( BleedoutMode_OnPlayerDowned )
    Bleedout_AddCallback_OnPlayerGiveFirstAid( BleedoutMode_OnPlayerRevived )

    //AddCallback_GameStateEnter( eGameState.Playing, SetBleedoutState )
    AddCallback_OnClientConnected( OnClientConnected )
    AddCallback_OnClientDisconnected( OnClientDisconnected )
    AddCallback_PlayerClassChanged( OnPlayerClassChanged )
    AddCallback_OnPlayerRespawned( OnPlayerRespawned )
    AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerGetsPilotLoadout )
    AddCallback_OnPlayerKilled( OnPlayerKilled )
    AddCallback_OnTouchHealthKit( "item_titan_battery", OnTouchBatteryPack )

	AddDamageCallbackSourceID( eDamageSourceId.human_execution, OnExecutionDamaged )

    // more score added, why it can only be done midgame?
    AddCallback_GameStateEnter( eGameState.Playing, SetBleedoutModeScoreEvent )
    //ScoreEvent_SetEarnMeterValues( "EliminatePilot", BLEEDOUT_MODE_ELIMINATE_PILOT_EARNED_VALUE, BLEEDOUT_MODE_ELIMINATE_PILOT_OWNED_VALUE )

    RegisterSignal( "GiveMeleeAfterGracePeriod" )

    /* // do these in riff, pretty annoying
    Riff_ForcePlayerBleedout( ePlayerBleedout.Enabled )
    BleedoutShared_Init( 
        GAMEMODE_BLEEDOUT_TIME, 
        GAMEMODE_FIRSTAID_TIME,
	    GAMEMODE_FIRSTAID_TIME_SELF, 
        GAMEMODE_FIRSTAID_HEAL_PERCENT,
	    GAMEMODE_AI_BLEEDING_PLAYER_MISS_CHANCE, 
        GAMEMODE_FORCE_WEAPON_HOLSTER,
	    GAMEMODE_DEATH_ON_TEAM_BLEEDOUT 
        )
    Bleedout_Init()
    */

    Riff_ForceTitanAvailability( eTitanAvailability.Never )
}

void function SetBleedoutState()
{
    

    //BleedoutShared_Init( 30, 4,8, 0.4,0.5, true,true )
}

// modified function
void function OnClientConnected( entity player )
{
    file.useFakeApexLoadout[ player.GetUID() ] <- false
    if( BLEEDOUT_MODE_ENABLE_SECOND_LOADOUT )
        AddButtonPressedPlayerInputCallback( player, IN_MELEE, SwitchLoadoutType )
    //AddButtonPressedPlayerInputCallback( player, IN_USE, GetShieldLeft )
    //AddButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, GetShieldLeft )

    // following are base mode status
    //file.lastDamageInfo[ player ] <- null // no idea now
	//file.playerSavedTitle[ player ] <- ""
	//file.incapShieldHealthTable[ player ] <- file.incapShieldMaxHealth
	file.playerIncapShieldTable[ player ] <- null
	file.bleedoutFakePlayers[ player ] <- null

	/*
	IncapShieldStruct emptyStruct
	emptyStruct.vortexSphere = null
	emptyStruct.shieldWallFX1P = null
	file.playerIncapShieldTable[ player ] <- emptyStruct
	*/
}

void function OnClientDisconnected( entity player )
{
    /* // onClientDisconnected can't handle this
    delete file.playerSavedTitle[ player ]
	delete file.incapShieldHealthTable[ player ]
	delete file.playerIncapShieldTable[ player ]
    */
}

void function OnPlayerClassChanged( entity player )
{
    print( "Running OnPlayerClassChanged()" )
    thread Bleedout_HealthRegenThink( player )
}

void function OnPlayerRespawned( entity player )
{
    if( !BLEEDOUT_MODE_ENABLE_SECOND_LOADOUT )
        return
    if( !file.useFakeApexLoadout[player.GetUID()] )
        SendHudMessage( player, "当前装备: 原版\n按 近战 切换至伪apex技能", -1, -0.3, 0, 255, 255, 255, 0, 10, 0 )
    else if( file.useFakeApexLoadout[player.GetUID()] )
        SendHudMessage( player, "当前装备: 伪apex技能\n按 近战 切换至原版", -1, -0.3, 0, 255, 255, 255, 0, 10, 0 )
}

void function OnPlayerGetsPilotLoadout( entity player, PilotLoadoutDef p )
{
    // FUCKOFFCLOAK( player )
    // don't enable EverythingNessy_Init(), will conflict, use it's function instead
    ClearNessy( player ) 
	thread SpawnNessyOutfit( player ) // become cuter!

    //entity meleeWeapon = player.GetOffhandWeapon( OFFHAND_MELEE )
    //if( IsValid( meleeWeapon ) )
    //    meleeWeapon.AddMod( "pushback_melee" )

    for ( int i = 0; i <= OFFHAND_MELEE; i++ ) // for better sloting
    {
        entity nowWeapon = player.GetOffhandWeapon( i )
        if( IsValid( nowWeapon ))
        {
            string className = nowWeapon.GetWeaponClassName()
            if( className == "mp_ability_cloak" )
            {
                player.TakeWeaponNow( className )
                player.GiveOffhandWeapon( "mp_ability_grapple", i )
            }
            else if( className == "mp_weapon_deployable_cover" )
            {
                player.TakeWeaponNow( className )
                player.GiveOffhandWeapon( "mp_weapon_hard_cover", i, ["hard_cover_always"] )
            }
        }
    }

    SyncedMelee_Disable( player )
    player.SetMaxHealth( BLEEDOUT_MODE_HEALTH )
    player.SetHealth( BLEEDOUT_MODE_HEALTH )
    player.SetShieldHealthMax( BLEEDOUT_MODE_SHIELD_HEALTH )
    player.SetShieldHealth( BLEEDOUT_MODE_SHIELD_HEALTH )

	player.GiveExtraWeaponMod( "bleedout_balance" )
	player.GiveExtraWeaponMod( "pushback_melee" )
	player.GiveExtraWeaponMod( "fuckoff_ordnance" )

    if( file.useFakeApexLoadout[player.GetUID()] ) // apex loadout players
    {
        AltPilot_ReplacePilotModel( player )
        GiveFakeApexLoadout( player )
    }
    if( BLEEDOUT_MODE_ENABLE_SECOND_LOADOUT )
        thread GiveMeleeAfterGracePeriod( player )
    else
        thread DelayedCheckMelee( player )

    // charge rifle chargehack specific!
    thread DelayedRestoreQuickChargeRifle( player )
}

// don't work for now! don't know why
void function DelayedRestoreQuickChargeRifle( entity player )
{
    player.EndSignal( "OnDestroy" )
    player.EndSignal( "OnDeath" )

    WaitFrame() // wait for weapons ready
    foreach ( entity weapon in player.GetMainWeapons() )
    {
        if ( weapon.HasMod( "quick_charge" ) )
            weapon.RemoveMod( "bleedout_balance" ) // remove it's damage reduction
    }
}

void function GiveMeleeAfterGracePeriod( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    player.Signal( "GiveMeleeAfterGracePeriod" )
    player.EndSignal( "GiveMeleeAfterGracePeriod" )
    player.TakeOffhandWeapon( OFFHAND_MELEE )

    while( true )
    {
        if( !( expect bool( player.s.inGracePeriod ) ) )
            break
        WaitFrame()
    }
	
    GivePlayerSpecialMelee( player )
}

void function DelayedCheckMelee( entity player )
{
	player.TakeOffhandWeapon( OFFHAND_MELEE )
    WaitFrame()
    if( IsAlive( player ) )
    {
        GivePlayerSpecialMelee( player )
    }
}

void function GivePlayerSpecialMelee( entity player )
{
	string meleeToGive = CoinFlip() ? "melee_pilot_kunai" : "melee_pilot_sword"
	if( !IsValid( player.GetOffhandWeapon( OFFHAND_MELEE ) ) )
        player.GiveOffhandWeapon( meleeToGive, OFFHAND_MELEE )
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
    ClearNessy( victim )
    // abandoned, only using emergency batteries
    /*
    entity battery = Rodeo_CreateBatteryPack()
    if( IsValid( battery ) )
    {
        battery.SetOrigin( victim.EyePosition() )
        battery.SetVelocity( < 0,0,1 > )
    }
    */
}

// since execution will leave player 1 health and redirect score to the knockdowner, adding exection shield should be done over here
void function OnExecutionDamaged( entity victim, var damageInfo )
{
	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
    entity attacker = DamageInfo_GetAttacker( damageInfo )
    // reward for executions
    if( !IsValid( attacker ) )
        return
    if( attacker.IsPlayer() )
    {
        if( attacker.GetShieldHealth() == attacker.GetShieldHealthMax() ) // shield full!
            return
        entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( attacker, GetParticleSystemIndex( $"P_xo_armor_body_CP" ), FX_PATTACH_POINT_FOLLOW, attacker.LookupAttachment( "CHESTFOCUS" ) )
        SetTeam( shieldFXHandle, attacker.GetTeam() )
        shieldFXHandle.SetOwner( attacker )
        EffectSetControlPointVector( shieldFXHandle, 1, <115, 247, 255> )
        
        int currentShieldHealth = attacker.GetShieldHealth()
        int shieldToRestore = int( min( attacker.GetShieldHealthMax() - currentShieldHealth, BLEEDOUT_MODE_EXECUTION_SHIELD_REWARD ) )
        if( shieldToRestore <= BLEEDOUT_MODE_EXECUTION_SHIELD_REWARD ) // consider shield is full, not showing a extra fx
            shieldFXHandle.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
        attacker.SetShieldHealth( min( attacker.GetShieldHealthMax(), attacker.GetShieldHealth() + shieldToRestore ) )
        SendHudMessage( attacker, "Executing an enemy\nRestored: " + string(shieldToRestore) + " shields!", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
        MessageToPlayer( attacker, eEventNotifications.VANGUARD_ShieldGain, attacker )

		//AddPlayerScore( attacker, "Execution", victim ) // do a manual score event here
    }
}

bool function OnTouchBatteryPack( entity player, entity batteryPack )
{
    if( !IsAlive( player ) )
        return false
    //if( IsValid( GetBatteryOnBack( player ) ) ) // player carring a battery
    //    return false
    // HACKED FIX!
    if( GetPlayerLastShieldBatteryUsedTime( player ) >= Time() - 1.0 ) // modified function in pilot_shield_battery.gnut
    {
        //print( GetPlayerLastShieldBatteryUsedTime( player ) >= Time() - 1.0 )    
        return false
    }
    SendHudMessage( player, "Press BOOST key\nTo use a shield battery", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )

    //Basically always return false since we don't want the battery pack to go away when being touched. ApplyBatteryToTitan() etc will deal with lifetime of battery
	return false
}

void function SetBleedoutModeScoreEvent()
{
    ScoreEvent_SetEarnMeterValues( "EliminatePilot", BLEEDOUT_MODE_ELIMINATE_PILOT_EARNED_VALUE, BLEEDOUT_MODE_ELIMINATE_PILOT_OWNED_VALUE )
    ScoreEvent_SetEarnMeterValues( "PilotAssist", BLEEDOUT_MODE_PILOT_ASSIST_EARNED_VALUE, BLEEDOUT_MODE_PILOT_ASSIST_OWNED_VALUE )
}

void function BleedoutMode_OnPlayerDowned( entity player, entity attacker, var damageInfo )
{
    print( "Running OnPlayerDowned()" )
	//player.Signal( "StopHealthRegenThink" )
    player.SetMaxHealth( BLEEDOUT_MODE_DOWNED_HEALTH * 5 )
    player.SetHealth( BLEEDOUT_MODE_DOWNED_HEALTH )

    Bleedout_PlayerDownedSound( player, attacker )
	Bleedout_PlayerDownedEffect( player, damageInfo )
	Bleedout_PlayerDownedObit( player, attacker, damageInfo ) // now only shows to attacker!

    EmitSoundOnEntityToTeam( player, "UI_Spawn_FriendlyPilot", player.GetTeam() )

    thread Bleedout_DeathProtection( player )
	thread Bleedout_PlayerHolsterWeapon( player ) // better fix
	/*
	string playerTitle = player.GetTitle()
	if( playerTitle != "#DEATH_BLEEDOUT" && playerTitle !=  )
		file.playerSavedTitle[player] = playerTitle
	*/
	//thread Bleedout_PlayerSlidePrevention( player )
    //thread Bleedout_FakePlayerThink( player ) // don't know how to do this
	// this should done before callbacks since it triggers a "OnClassChange"
	// done using Bleedout_PlayerMovementLimiter()
	//Bleedout_DiableWallrunAndDoubleJump( player ) 
	
	thread Bleedout_ScreenFadeThink( player )
	thread Bleedout_EnemySpottingHighlight( player )
	if( Bleedout_GetForceWeaponHolster() ) // if player is able to use a weapon, we don't enable incap shields
		thread Bleedout_IncapShieldThink( player )
    if( file.executingBleedingEnabled )
		thread Bleedout_BecomeExecutionTarget( player )
}

void function BleedoutMode_OnPlayerRevived( entity playerToRes, entity playerHealer )
{
    print( "Running OnPlayerRevived()" )
    // this should done before callbacks since it triggers a "OnClassChange"
	// done using Bleedout_PlayerMovementLimiter()
	//Bleedout_EnableWallrunAndDoubleJump( playerToRes )
	//player.Signal( "StopHealthRegenThink" )
    playerToRes.SetMaxHealth( BLEEDOUT_MODE_HEALTH )
    playerToRes.p.lastDamageTime = Time()
    thread Bleedout_PlayerForceStand( playerToRes ) // so players won't have to manually cancel their crouch, but might be annoying for reviving behind low covers

    // do a reward for playerHealer
    if( playerHealer.GetShieldHealth() == playerHealer.GetShieldHealthMax() ) // shield full!
        return
    if( playerHealer == playerToRes ) // selfRes
        return
    entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( playerHealer, GetParticleSystemIndex( $"P_xo_armor_body_CP" ), FX_PATTACH_POINT_FOLLOW, playerHealer.LookupAttachment( "CHESTFOCUS" ) )
    SetTeam( shieldFXHandle, playerHealer.GetTeam() )
    shieldFXHandle.SetOwner( playerHealer )
    EffectSetControlPointVector( shieldFXHandle, 1, <115, 247, 255> )
    
    int currentShieldHealth = playerHealer.GetShieldHealth()
    int shieldToRestore = int( min( playerHealer.GetShieldHealthMax() - currentShieldHealth, BLEEDOUT_MODE_REVIVING_FRIENDLY_SHIELD_REWARD ) )
    if( shieldToRestore <= BLEEDOUT_MODE_REVIVING_FRIENDLY_SHIELD_REWARD ) // consider shield is full, not showing a extra fx
        shieldFXHandle.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
    playerHealer.SetShieldHealth( min( playerHealer.GetShieldHealthMax(), playerHealer.GetShieldHealth() + shieldToRestore ) )
    SendHudMessage( playerHealer, "Reviving a teammate\nResotred: " + string(shieldToRestore) + " shields!", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
    MessageToPlayer( playerHealer, eEventNotifications.VANGUARD_ShieldGain, playerHealer )
}

void function SwitchLoadoutType( entity player )
{
    if( !Loadouts_CanGivePilotLoadout( player ) )
        return

    string uid = player.GetUID()

    if( !file.useFakeApexLoadout[uid] )
    {
        file.useFakeApexLoadout[uid] = true
        SendHudMessage( player, "当前装备: 伪apex技能\n按 近战 切换至原版", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
        Loadouts_TryGivePilotLoadout( player )
    }
    else if( file.useFakeApexLoadout[uid] )
    {
        file.useFakeApexLoadout[uid] = false
        SendHudMessage( player, "当前装备: 原版\n按 近战 切换至伪apex技能", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
        Loadouts_TryGivePilotLoadout( player )
    }
}

void function GiveFakeApexLoadout( entity player )
{
    string tacticalName = player.GetOffhandWeapon( OFFHAND_SPECIAL ).GetWeaponClassName()
    string ordnanceName = player.GetOffhandWeapon( OFFHAND_ORDNANCE ).GetWeaponClassName()

    if( ordnanceName == "mp_weapon_grenade_gravity" )
        GiveReplacementOrdnance( player )

    player.TakeWeaponNow( tacticalName )
    player.TakeWeaponNow( ordnanceName )

    switch( tacticalName )
    {
        case "mp_weapon_hard_cover":
            player.GiveOffhandWeapon( "mp_weapon_hard_cover", OFFHAND_SPECIAL, ["gibraltar_shield"] )
            break
        case "mp_ability_heal":
			player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_SPECIAL, ["jump_pad"] )
            break
		case "mp_ability_grapple":
			player.GiveOffhandWeapon( "mp_ability_grapple", OFFHAND_SPECIAL, ["zipline_gun"] )
            break
		case "mp_ability_holopilot":
			player.GiveOffhandWeapon( "mp_ability_holopilot", OFFHAND_SPECIAL, ["holoshift"] )
            break
		case "mp_ability_shifter":
            player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, ["wraith_portal", "amped_tacticals"] )
            break
        case "mp_weapon_grenade_sonar":
            player.GiveOffhandWeapon( "mp_weapon_grenade_gravity", OFFHAND_SPECIAL, ["gravity_lift"] )
            break
    }

    switch( ordnanceName )
    {
        case "mp_weapon_frag_grenade":
            player.GiveOffhandWeapon( "mp_titanability_tether_trap", OFFHAND_ORDNANCE, ["pilot_tether"] )
            break
        case "mp_weapon_grenade_emp":
			player.GiveOffhandWeapon( "mp_weapon_arc_trap", OFFHAND_ORDNANCE, ["limited_arc_trap", "multiplayer_arc_trap"] )
            break
        case "mp_weapon_thermite_grenade":
			player.GiveOffhandWeapon( "mp_weapon_thermite_grenade", OFFHAND_ORDNANCE, ["flamewall_grenade"] )
            break
        case "mp_weapon_grenade_electric_smoke":
			player.GiveOffhandWeapon( "mp_titanability_slow_trap", OFFHAND_ORDNANCE, ["gas_trap"] )
            break
        case "mp_weapon_satchel":
            player.GiveOffhandWeapon( "mp_weapon_satchel", OFFHAND_ORDNANCE, ["proximity_mine"] )
            break
        default:
            player.GiveOffhandWeapon( "mp_weapon_thermite_grenade", OFFHAND_ORDNANCE )
    }
}

void function GiveReplacementOrdnance( entity player )
{
    string tacticalName = player.GetOffhandWeapon( OFFHAND_SPECIAL ).GetWeaponClassName()
    string ordnanceName = player.GetOffhandWeapon( OFFHAND_ORDNANCE ).GetWeaponClassName()
        
    player.TakeWeaponNow( ordnanceName )
    switch( tacticalName )
    {
        case "mp_ability_grapple":
            player.GiveOffhandWeapon( "mp_titanability_tether_trap", OFFHAND_ORDNANCE, ["pilot_tether"] )
            break
        case "mp_ability_heal":
			player.GiveOffhandWeapon( "mp_weapon_arc_trap", OFFHAND_ORDNANCE, ["limited_arc_trap", "multiplayer_arc_trap"] )
            break
        case "mp_weapon_hard_cover":
			player.GiveOffhandWeapon( "mp_weapon_thermite_grenade", OFFHAND_ORDNANCE, ["flamewall_grenade"] )
            break
        case "mp_ability_shifter":
			player.GiveOffhandWeapon( "mp_titanability_slow_trap", OFFHAND_ORDNANCE, ["gas_trap"] )
            break
        case "mp_ability_holopilot":
            player.GiveOffhandWeapon( "mp_weapon_satchel", OFFHAND_ORDNANCE, ["proximity_mine"] )
            break
        default:
            player.GiveOffhandWeapon( "mp_weapon_thermite_grenade", OFFHAND_ORDNANCE )
    }
}

void function GetShieldLeft( entity player )
{
    SendHudMessage( player, "剩余护盾值: " + string( player.GetShieldHealth() ) + " / " + string( player.GetShieldHealthMax() ), -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
}


// Gamemode Functions!!!
bool function GamemodeBleedout_PlayerDownedCheck( entity victim, var damageInfo )
{
	// doing a better check including shield health
	if ( victim.GetHealth() + victim.GetShieldHealth() - DamageInfo_GetDamage( damageInfo ) <= 0 )
		return true

	return false
}

void function Bleedout_PlayerHolsterWeapon( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function():( player )
		{
			if( IsValid( player ) )
				player.Server_TurnOffhandWeaponsDisabledOff()
		}
	)

	//wait file.protectionDuration * 0.5 // wait for player switching to mp_weapon_gunship_missile
	while( true )
	{
		player.HolsterWeapon()
		player.Server_TurnOffhandWeaponsDisabledOn()
		WaitFrame() // wait in the first loop
	}
}

void function Bleedout_PlayerDownedSound( entity victim, entity attacker )
{
	if( attacker.IsPlayer() )
	{
		if( victim.IsMechanical() )
		{
			if( attacker != victim )
			{
				// this has been handled by DF_KILLSHOT
				//EmitSoundOnEntityOnlyToPlayer( victim, attacker, "flesh_bulletimpact_killshot_1p_vs_3p" )
				EmitSoundOnEntityExceptToPlayer( victim, attacker, "android_bulletimpact_killshot_3p_vs_3p" )
			}
		}
		else
		{
			if( attacker != victim )
			{
				// this has been handled by DF_KILLSHOT
				//EmitSoundOnEntityOnlyToPlayer( victim, attacker, "flesh_bulletimpact_killshot_1p_vs_3p" )
				EmitSoundOnEntityExceptToPlayer( victim, attacker, "flesh_heavy_bulletimpact_killshot_3p_vs_3p" )
			}
		}
	}
	else
	{
		if( victim.IsMechanical() )
			EmitSoundOnEntityExceptToPlayer( victim, victim, "android_bulletimpact_killshot_3p_vs_3p" )
		else
			EmitSoundOnEntityExceptToPlayer( victim, victim, "flesh_heavy_bulletimpact_killshot_3p_vs_3p" )
	}

	// what ever we do, emit sound on victim themselves, fx handling in Bleedout_PlayerDownedEffect()
	EmitSoundOnEntityOnlyToPlayer( victim, victim, "flesh_bulletimpact_killshot_1p_vs_3p" )
}

void function Bleedout_PlayerDownedEffect( entity player, var damageInfo )
{
	if( !( DamageInfo_GetCustomDamageType( damageInfo ) & DF_BULLET ) ) // not a bullet damage type
		return
	if( player.IsMechanical() )
	{
		// don't show mechanic downed effect to owner themselves, it's annoying!
		int particleIndex = GetParticleSystemIndex( $"xo_damage_exp_2" )
		int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )
		entity fx = StartParticleEffectOnEntity_ReturnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		SetTeam( fx, player.GetTeam() )
		fx.SetOwner( player )
		fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY
		thread FastStopParticle( fx, 2.5 )
		//entity ownerFx = StartParticleEffectOnEntity_ReturnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		//fx.SetOwner( player )
		//fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
		//thread FastStopParticle( fx, 1.0 )
	}
	else
	{
		int particleIndex = GetParticleSystemIndex( $"death_pinkmist_LG_nochunk" )
		int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )
		entity fx = StartParticleEffectOnEntity_ReturnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		fx.SetOwner( player )
		fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY
	}
}

void function FastStopParticle( entity fx, float delay )
{
	fx.EndSignal( "OnDestroy" )
	wait delay
	EffectStop( fx )
}

void function Bleedout_PlayerDownedObit( entity ent, entity attacker, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	// trigger_hurt is no longer networked, so the "attacker" fails to display obituaries
	if ( attacker )
	{
		if( !attacker.IsPlayer() || ent == attacker ) // now only shows to attacker!
			return

		string attackerClassname = attacker.GetClassName()

		if ( attackerClassname == "trigger_hurt" || attackerClassname == "trigger_multiple" )
			attacker = GetEntByIndex( 0 ) // worldspawn
	}

	int attackerEHandle = attacker ? attacker.GetEncodedEHandle() : -1

	int victimEHandle = ent.GetEncodedEHandle()
	int scriptDamageType = DamageInfo_GetCustomDamageType( damageInfo )
	int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	if ( scriptDamageType & DF_VORTEX_REFIRE )
		damageSourceId = eDamageSourceId.mp_titanweapon_vortex_shield

	if ( IsValidHeadShot( damageInfo, ent ) )
		scriptDamageType = scriptDamageType | DF_HEADSHOT
	else
		scriptDamageType = scriptDamageType & (~DF_HEADSHOT)
	
	// now only shows to attacker!
	//Remote_CallFunction_NonReplay( attacker, "ServerCallback_OnEntityKilled", attackerEHandle, victimEHandle, scriptDamageType, damageSourceId )
	foreach ( entity player in GetPlayerArray() )
	{
		if( player != ent ) // not player themselves only, or the client will consider them as died then hide their hud
			Remote_CallFunction_NonReplay( player, "ServerCallback_OnEntityKilled", attackerEHandle, victimEHandle, scriptDamageType, damageSourceId )
	}

	// moving from OnPlayerBleedoutBegin(), show a popup to attacker
	if( attacker != ent )
	{
		if( attacker.IsPlayer() && ent.IsPlayer() )
		{
			//NSSendPopUpMessageToPlayer( attacker, "擊倒 " + ent.GetPlayerName() )
			NSSendPopUpMessageToPlayer( ent, "Downed by " + attacker.GetPlayerName() )
		}
	}
}

void function Bleedout_DeathProtection( entity player )
{
	player.SetInvulnerable()
	wait file.protectionDuration
	if( IsValid( player ) )
		player.ClearInvulnerable()
}

void function Bleedout_PlayerSlidePrevention( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	//bool lastFrameSlide // for checks
	while( true )
	{
		WaitFrame()
		if( player.IsSliding() && player.IsOnGround() ) // sometimes sliding off a roof will remain slide state, do a check
		{
			player.SetVelocity( < 0,0,0 > )
		//	lastFrameSlide = true
		//	continue
		}
		//if( lastFrameSlide && !player.IsOnGround() ) // prevent player being stopped midair
		//	player.SetVelocity( < 0,0,100 > )
		//lastFrameSlide = false
	}
}

void function Bleedout_DiableWallrunAndDoubleJump( entity player )
{
	// WARN!!! This triggers a "OnClassChange"
	int skin = player.GetSkin()
	int camo = player.GetCamo()
	asset modelName = player.GetModelName()

	string setFile = player.GetPlayerSettings()
	array<string> settingMods = player.GetPlayerSettingsMods()
	if( !settingMods.contains( "disable_wallrun" ) )
		settingMods.append( "disable_wallrun" )
	if( !settingMods.contains( "disable_doublejump" ) )
		settingMods.append( "disable_doublejump" )

	player.SetPlayerSettingsWithMods( setFile, settingMods )
	player.SetSkin( skin )
	player.SetCamo( camo )
	player.SetModel( modelName )
}

void function Bleedout_EnableWallrunAndDoubleJump( entity player )
{
	// WARN!!! This triggers a "OnClassChange"
	int skin = player.GetSkin()
	int camo = player.GetCamo()
	asset modelName = player.GetModelName()

	string setFile = player.GetPlayerSettings()
	array<string> settingMods = player.GetPlayerSettingsMods()
	settingMods.removebyvalue( "disable_wallrun" )
	settingMods.removebyvalue( "disable_doublejump" )

	player.SetPlayerSettingsWithMods( setFile, settingMods )
	player.SetSkin( skin )
	player.SetCamo( camo )
	player.SetModel( modelName )
}

void function Bleedout_PlayerForceStand( entity player )
{
	player.UnforceCrouch()
    // if player holding crouch we don't make them forced stand up!
    if( player.IsInputCommandHeld( IN_DUCK ) || player.IsInputCommandHeld( IN_DUCKTOGGLE ) )
        return
	player.ForceStand()
	wait 0.2
	if( IsValid( player ) )
		player.UnforceStand()
}

void function Bleedout_EnemySpottingHighlight( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function(): ( player )
		{
			Highlight_ClearEnemyHighlight( player )
		}
	)

	while( true )
	{
		Highlight_SetEnemyHighlight( player, "sp_enemy_pilot" )
		player.Highlight_SetParam( 2, 0, < 2,0,0 > ) // light right
		WaitFrame()
	}
}

void function Bleedout_BecomeExecutionTarget( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	wait file.protectionDuration // do need this to prevent execution invulnerable players

	entity hitbox = CreateHitboxEntityForPlayer( player )
	hitbox.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( hitbox )
		{
			//print( "hitbox Think End" )
			if( IsValid( hitbox ) )
				hitbox.Destroy()
		}
	)

	while( true )
	{
		// temp unsetUsable() when player getting firstaid by friendlies
		if( Bleedout_IsPlayerGettingFirstAid( player ) && !Bleedout_IsPlayerSelfHealing( player ) )
		{
			hitbox.UnsetUsable()
			//print( "hitbox being UnsetUsable()" )
		}
		else if( !player.ContextAction_IsActive() ) // assuming this is player being executing, wait for it
		{	
			hitbox.SetUsableByGroup( "enemies pilot" )
			//print( "hitbox being SetUsable()" )
		}

		// defensive fixs( actually messed things up
		/*
		if( !player.ContextAction_IsActive() ) 
		{
			hitbox.SetUsableByGroup( "enemies pilot" )
			//print( "hitbox being SetUsable()" )
		}
		else
		{
			hitbox.UnsetUsable()
			//print( "hitbox being UnsetUsable()" )
		}
		*/
		WaitFrame()
	}
}

entity function CreateHitboxEntityForPlayer( entity player )
{
	entity hitbox = CreatePropScript( BLEEDOUT_EXECUTION_HITBOX_MODEL )
	hitbox.SetParent( player, "CHESTFOCUS" )
	//hitbox.SetOrigin( < 30, 0, 0 > )
	//hitbox.SetLocalAngles( < 90, -90, 0 > )
	hitbox.SetTakeDamageType( DAMAGE_NO )
	SetTeam( hitbox, player.GetTeam() )
	SetObjectCanBeMeleed( hitbox, false )
	//hitbox.kv.modelscale = 0.1
	hitbox.kv.solid = SOLID_VPHYSICS
	hitbox.Hide()
	
	hitbox.SetOwner( player )
	
    hitbox.SetUsableByGroup( "enemies pilot" )
    hitbox.SetUsePrompts( "在目標身後按住 %use% 進行處決", "在目標身後按下 %use% 進行處決" )

    AddCallback_OnUseEntity( hitbox, ExecuteHitboxOwner )
	return hitbox
}

var function ExecuteHitboxOwner( var hitbox, var player )
{
	expect entity( player )
	expect entity( hitbox )
	thread ExecuteHitboxOwner_Threaded( hitbox, player )
}

void function ExecuteHitboxOwner_Threaded( entity hitbox, entity player )
{
	entity owner = hitbox.GetOwner()
	
	hitbox.UnsetUsable()
	// avoid this kind of crash... redo a SetUsable
	if( player.ContextAction_IsActive() ) // doing a execution?
		return
	if( Bleedout_IsPlayerBleeding( player ) ) // dont let downed players execute each other :(
		return
	if( !IsAlive( owner ) ) // owner may died before executions starts
		return
	if( owner.ContextAction_IsActive() ) // already being executed?
		return
	if( owner.GetTeam() == player.GetTeam() ) // well this can't fix wrong notifications caused by swiching team
	{
		WaitFrame()
		if( IsValid( hitbox ) )
		{
			hitbox.SetUsableByGroup( "enemies pilot" )
		}
		return
	}

	SyncedMeleeChooser ornull actions = GetSyncedMeleeChooserForPlayerVsTarget( player, owner )
	if( actions == null )
		return
	expect SyncedMeleeChooser( actions )
	SyncedMelee ornull action = FindBestSyncedMelee( player, owner, actions )
	if( action == null )
		return
	expect SyncedMelee( action )

	// start execution
	// add signals that cancels executions
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "BleedOut_OnStartDying" )
	owner.EndSignal( "OnDestroy" )
	owner.EndSignal( "OnDeath" )

	OnThreadEnd(
		function(): ( owner, hitbox )
		{
			if( IsValid( hitbox ) )
			{
				if( !IsAlive( owner ) ) // owner died
					hitbox.Destroy()
				else
				{
					hitbox.SetUsableByGroup( "enemies pilot" )
				}
			}
		}
	)

	thread Bleedout_PlayerSyncedMeleeEffect( player ) // screen effect
	thread Bleedout_PlayerSyncedMeleeEffect( owner )
	waitthread MeleeThread_PilotVsEnemy( action, player, owner )
}

void function Bleedout_PlayerSyncedMeleeEffect( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function() : ( player )
		{
			if ( IsValid( player ) )
			{
				RemoveCinematicFlag( player, CE_FLAG_EXECUTION )
                RemoveCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
			}
		}
	)

    AddCinematicFlag( player, CE_FLAG_EXECUTION )
    AddCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )

    WaittillAnimDone( player )
}

void function Bleedout_IncapShieldThink( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	// before OnThreadEnd()
	array<int> statusEffectHandles = []

	OnThreadEnd(
		function(): ( player, statusEffectHandles )
		{
			if( IsValid( player ) )
			{
				/* // abandoned
				entity vortexSphere = file.playerIncapShieldTable[ player ].vortexSphere
				entity shieldWallFX1P = file.playerIncapShieldTable[ player ].shieldWallFX1P
				if( IsValid( vortexSphere ) )
					vortexSphere.Destroy()
				if( IsValid( shieldWallFX1P ) )
					shieldWallFX1P.Destroy()
				*/
				entity vortexSphere = file.playerIncapShieldTable[ player ]
				if( IsValid( vortexSphere ) )
					vortexSphere.Destroy()
				
				foreach( int effect in statusEffectHandles )
					StatusEffect_Stop( player, effect )
			}
		}
	)

	//entity vortexSphere = CreateIncapShieldForBleedingPlayer( player )
	//HideIncapShieldVortexSphere( vortexSphere ) // later we enable it
	//vortexSphere.EndSignal( "OnDestroy" )
	
	wait file.protectionDuration *0.5

	entity vortexSphere = CreateIncapShieldForBleedingPlayer( player )
	vortexSphere.EndSignal( "OnDestroy" )

	float lastDryFireTime = 0
	bool vortexShown = false
	bool hasStatusEffect = true
	while( true )
	{
		WaitFrame()

		// not holding attack or be in special state
		if( IsInValidIncapShieldState( player ) && player.IsInputCommandHeld( IN_ATTACK ) ) 
		{
			if( !hasStatusEffect )
			{
				statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.5 ) )
				//statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.3 ) )
				hasStatusEffect = true
			}

			if( !vortexShown )
			{
				EmitSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
				HACK_ShowIncapShieldVortexSphere( vortexSphere, player ) // hacking function
				//ShowIncapShieldVortexSphere( vortexSphere )
				//CreateIncapShieldWallFX( vortexSphere ) // no need for now!
				vortexShown = true
			}
			if( IsValid( vortexSphere.e.shieldWallFX ) )
				EffectSetControlPointVector( vortexSphere.e.shieldWallFX, 1, GetIncapShieldCurrentColor( 1.0 - GetHealthFrac( vortexSphere ) ) )
			
		}
		else// if( player.IsInputCommandHeld( IN_ATTACK ) )
		{
			//print( "Stopping Incap Shield" )
			StopSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
			//StopIncapShieldWallFX( vortexSphere ) // no need for now!
			HACK_TempHideIncapShieldVortexSphere( vortexSphere ) // stupid function
			//HideIncapShieldVortexSphere( vortexSphere )
			vortexShown = false
			if( hasStatusEffect )
			{
				foreach( int effect in statusEffectHandles )
					StatusEffect_Stop( player, effect )
			}
			hasStatusEffect = false
		}
	}

	/* // really should rework this
	while( true )
	{
		WaitFrame()
		//print( file.IsGettingFirstAidFrom[ player ] == player )

		// this continued everything, fuck me
		//if( !IsInValidIncapShieldState( player ) )
		//	continue

		if( file.incapShieldHealthTable[ player ] == 0 )
		{
			if( lastDryFireTime + 1.0 <= Time() && player.IsInputCommandHeld( IN_ATTACK ) )
			{
				EmitSoundOnEntityOnlyToPlayer( player, player, "pistol_dryfire" )
				lastDryFireTime = Time()
			}
			continue
		}

		//entity vortexSphere = file.playerIncapShieldTable[ player ].vortexSphere
		entity vortexSphere = file.playerIncapShieldTable[ player ]
		//print( IsValid( vortexSphere ) )
		//print( "Bleedout_IsPlayerGettingFirstAid( player ) = " + string( Bleedout_IsPlayerGettingFirstAid( player ) ) )
		//print( "Bleedout_IsPlayerSelfHealing( player ) = " + string( Bleedout_IsPlayerSelfHealing( player ) ) )
		//print( "player.ContextAction_IsActive() = " + string( player.ContextAction_IsActive() ) )
		//print( IsInValidIncapShieldState( player ) )

		// not holding attack or be in special state
		if( IsInValidIncapShieldState( player ) && player.IsInputCommandHeld( IN_ATTACK ) ) 
		{
			//print( "Looping Here but doing nothing" )
			//print( "Looping Here!!" )
			if( !IsValid( vortexSphere ) ) // new vortex
			{
				//print( "ReCreating Incap Shield" )
				CreateIncapShieldForBleedingPlayer( player )
				statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.5 ) )
				statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.3 ) )
			}
			else // last vortexSphere exists
			{
				EffectSetControlPointVector( vortexSphere.e.shieldWallFX, 1, GetIncapShieldCurrentColor( 1.0 - GetHealthFrac( vortexSphere ) ) )
				if( !loopSoundPlaying )
				{
					EmitSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
					loopSoundPlaying = true
				}
			}
			
		}
		else// if( player.IsInputCommandHeld( IN_ATTACK ) )
		{
			if( IsValid( vortexSphere ) )
			{
				//print( "Stopping Incap Shield" )
				StopSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
				loopSoundPlaying = false
				vortexSphere.Destroy()
				foreach( int effect in statusEffectHandles )
					StatusEffect_Stop( player, effect )
			}
		}
	}
	*/
}

bool function IsInValidIncapShieldState( entity player )
{
	if( Bleedout_IsPlayerGettingFirstAid( player ) ||
		Bleedout_IsPlayerSelfHealing( player ) ||
		player.ContextAction_IsActive() )
		return false

	return true
}

// should set a different one since it's fx has been reset angle!
const int INCAP_SHIELD_RADIUS = 35
const int INCAP_SHIELD_HEIGHT = 60
const int INCAP_SHIELD_FOV = 75

const asset INCAP_SHIELD_EFFECT_NAME = $"P_anti_titan_shield_3P"

entity function CreateIncapShieldForBleedingPlayer( entity player )
{
	vector angles = VectorToAngles( player.EyeAngles() )
	int maxHealth = file.incapShieldMaxHealth
	int health = file.incapShieldMaxHealth//file.incapShieldHealthTable[ player ]

	// doing hardcode here, guess no need to change( and I cant easily change it
	// vortexSphere
	entity vortexSphere = CreateShieldWithSettings( player.GetOrigin(), angles, INCAP_SHIELD_RADIUS, INCAP_SHIELD_HEIGHT, INCAP_SHIELD_FOV, 9999, maxHealth, INCAP_SHIELD_EFFECT_NAME )
	//file.playerIncapShieldTable[ player ].vortexSphere = vortexSphere // no need to use 1p things
	file.playerIncapShieldTable[ player ] = vortexSphere
	
	vortexSphere.SetHealth( health )
	vortexSphere.SetOwner( player )
	vortexSphere.SetBlocksRadiusDamage( true )
	SetTeam( vortexSphere, player.GetTeam() )
	vortexSphere.SetParent( player, "ORIGIN" )
	vortexSphere.e.shieldWallFX.DisableHibernation() // prevent fx from fading out
	vortexSphere.e.shieldWallFX.SetAngles( < 20,0,94 > )
	vortexSphere.e.shieldWallFX.SetOrigin( < 31,0,32 > )

	//thread IncapShieldHealthDisplayer( player, vortexSphere ) // maybe no need to have this too dumb?
	//thread IncapShieldMoverThink( player, vortexSphere ) // let player move the incap shield
	
	vortexSphere.SetDamageNotifications( false ) // no hitmarkers?
	if( file.invulnerableIncapShield )
	{
		vortexSphere.SetInvulnerable()
		vortexSphere.SetTakeDamageType( DAMAGE_NO )
	}
	else
	{	
		// this thing don't work for a vortexSphere?
		//AddEntityCallback_OnDamaged( vortexSphere, IncapShieldTableUpdate )
		//thread TrackPlayerIncapShieldHealth( vortexSphere, player )
	}

	return vortexSphere
	

	// temp
	//vortexSphere.e.shieldWallFX.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY)

	/*
	// Shield wall fx control point
	entity cpoint = CreateEntity( "info_placement_helper" )
	SetTargetName( cpoint, UniqueString( "shield_wall_controlpoint" ) )
	DispatchSpawn( cpoint )

	// Shield wall fx
	entity shieldWallFX1P = StartParticleEffectInWorld_ReturnEntity( GetParticleSystemIndex( $"P_anti_titan_shield_3P" ), < 20,0,48 >, < 20,0,95 > )
	file.playerIncapShieldTable[ player ].shieldWallFX1P = shieldWallFX1P

	shieldWallFX1P.SetOwner( player )
	shieldWallFX1P.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
	EffectSetControlPointVector( shieldWallFX1P, 1, GetIncapShieldCurrentColor( 1.0 - GetHealthFrac( vortexSphere ) ) )
	shieldWallFX1P.SetParent( vortexSphere )

	thread Stop1PFXOnDestroy( vortexSphere, shieldWallFX1P )
	*/
}

// maybe no need to have this?
void function IncapShieldHealthDisplayer( entity player, entity vortexSphere )
{
	table playerInfo = {}
	playerInfo.activeWeaponName <- ""

	entity activeWeapon = player.GetActiveWeapon()
	if ( IsValid( activeWeapon ) )
		playerInfo.activeWeaponName = activeWeapon.GetWeaponClassName()

	entity ammoWeapon = player.GiveWeapon( "mp_weapon_gunship_missile", ["incap_shield_modifier"] )
	player.DeployWeapon() // deploy once to make activeWeapon change
	player.SetActiveWeaponByName( "mp_weapon_gunship_missile" )
	//player.HolsterWeapon()
	player.EndSignal( "OnDestroy" )
	vortexSphere.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( player, ammoWeapon, playerInfo )
		{
			if ( IsValid( ammoWeapon ) )
				ammoWeapon.Destroy()
			if ( IsValid( player ) )
			{
				string formerWeapon = string( playerInfo.activeWeaponName )
				if ( PlayerHasWeapon( player, formerWeapon ) )
					player.SetActiveWeaponByName( formerWeapon )
				else
				{
					array<entity> mainWeapons = player.GetMainWeapons()
					if ( mainWeapons.len() > 0 )
						player.SetActiveWeaponBySlot( 0 )
				}
			}
		}
	)

	if ( file.invulnerableIncapShield )
	{
		ammoWeapon.SetWeaponPrimaryAmmoCount( 1 )
		WaitForever()
	}
	while ( true )
	{
		ammoWeapon.SetWeaponPrimaryAmmoCount( vortexSphere.GetHealth() )
		WaitFrame()
	}
}

void function HACK_ShowIncapShieldVortexSphere( entity vortexSphere, entity player )
{
	// this is not very nice!
	vortexSphere.SetParent( player, "ORIGIN" )
	// re-enable shieldWallFx
	EntFireByHandle( vortexSphere.e.shieldWallFX, "Start", "", 0, null, null )
}

// this is basically not letting any player shoot the vortex, really dumb
void function HACK_TempHideIncapShieldVortexSphere( entity vortexSphere )
{
	// stop shieldWallFx for a while
	EntFireByHandle( vortexSphere.e.shieldWallFX, "Stop", "", 0, null, null )
	vortexSphere.ClearParent()
	vortexSphere.SetOrigin( < -9999, -9999, -9999 > ) // so player can never hit it
}


// WARNS: this is unfinished! can't handle it's angles, don't know why
void function IncapShieldMoverThink( entity owner, entity vortexSphere )
{
	// signals goes here
	owner.EndSignal( "OnDestroy" )
	vortexSphere.EndSignal( "OnDestroy" )

	entity mover = CreateScriptMover()
	mover.SetOrigin( owner.GetOrigin() )
	//vector moverAngles = owner.GetAngles()
	//mover.SetAngles( AnglesCompose( moverAngles, <0,0,180> ) )
	//vector ownerAngles = owner.EyeAngles()
	//mover.SetAngles( < 0, ownerAngles.y, 0 > )

	//mover.SetParent( owner )
	vortexSphere.SetParent( mover )
	// offset for each things
	vortexSphere.e.shieldWallFX.SetAngles( < 20, 0, 94 > )
	vortexSphere.e.shieldWallFX.SetOrigin( < 31, 0, 32 > )

	OnThreadEnd(
		function(): ( mover )
		{
			if ( IsValid( mover ) )
			{
				mover.Destroy()
			}
		}
	)

	while ( true )
	{
		UpdateShieldPosition( mover, owner )
	}
}

const float INCAP_SHIELD_PITCH_LIMIT = 30 // for better visual and limit player's protection
void function UpdateShieldPosition( entity mover, entity owner )
{
	vector angles = owner.EyeAngles()
	//print( owner.EyeAngles() )
	//print( VectorToAngles( owner.GetViewVector() ) )
	int dist = 10 // needs this to protect moving forward players
	vector offset = AnglesToForward( < 0, angles.y, 0 > ) * dist
	mover.NonPhysicsMoveTo( owner.GetOrigin() + offset, 0.1, 0.0, 0.0 )

	//float yaw = angles.y
	//yaw %= 360
	//mover.NonPhysicsRotateTo( <0,yaw,180>, 1.35, 0, 0 )
	vector angleOffset = < angles.x, angles.y, 0 >
	angleOffset = ClampPitch( angleOffset )
	mover.NonPhysicsRotateTo( angleOffset, 0.15, 0, 0 )

	WaitFrame()
}

vector function ClampPitch( vector angles )
{
	if ( angles.x >= 30 )
		angles.x = 30
	if ( angles.x <= -30 )
		angles.x = -30
	return angles
}

// not solid can't handle vortexSphere for some reason
/*
void function ShowIncapShieldVortexSphere( entity vortexSphere )
{
	// re-enable shieldWallFx
	EntFireByHandle( vortexSphere.e.shieldWallFX, "Start", "", 0, null, null )
	vortexSphere.Solid() // start protecting the owner
}

void function HideIncapShieldVortexSphere( entity vortexSphere )
{
	// stop shieldWallFx for a while
	EntFireByHandle( vortexSphere.e.shieldWallFX, "Stop", "", 0, null, null )
	vortexSphere.NotSolid() // so it won't block any bullets
}

void function StopIncapShieldWallFX( entity vortexSphere )
{
	entity shieldWallFX = vortexSphere.e.shieldWallFX
	if( !IsValid( shieldWallFX ) )
		return

	entity cpoint = shieldWallFX.e.cpoint
	shieldWallFX.e.cpoint = null
	if( IsValid( cpoint ) )
		cpoint.Destroy()

	StopShieldWallFX( vortexSphere )
}

entity function CreateIncapShieldWallFX( entity vortexSphere )
{
	// Shield wall fx control point
	entity cpoint = CreateEntity( "info_placement_helper" )
	SetTargetName( cpoint, UniqueString( "shield_wall_controlpoint" ) )
	DispatchSpawn( cpoint )

	// Shield wall fx
	entity shieldWallFX = PlayFXWithControlPoint( INCAP_SHIELD_EFFECT_NAME, < 0,0,0 >, cpoint, -1, null, < 0,0,0 >, C_PLAYFX_LOOP )
	vortexSphere.e.shieldWallFX = shieldWallFX
	shieldWallFX.e.cpoint = cpoint
	shieldWallFX.SetParent( vortexSphere )
	shieldWallFX.SetAngles( < 20,0,94 > )
	shieldWallFX.SetOrigin( < 31,0,32 > )

	return shieldWallFX
}

void function Stop1PFXOnDestroy( entity vortexSphere, entity shieldWallFX1P )
{
	vortexSphere.EndSignal( "OnDestroy" )
	shieldWallFX1P.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( vortexSphere, shieldWallFX1P )
		{
			if( IsValid( shieldWallFX1P ) )
				shieldWallFX1P.Destroy()
		}
	)

	WaitForever()
}
*/

const vector BLEEDOUT_INCAP_SHIELD_COLOR_FULL		 = <115, 247, 255>	// blue
const vector BLEEDOUT_INCAP_SHIELD_COLOR_MED		 = <200, 128, 80>	// orange
const vector BLEEDOUT_INCAP_SHIELD_COLOR_EMPTY		 = <200, 80, 80>	// red

vector function GetIncapShieldCurrentColor( float chargeFrac, vector fullHealthColor = BLEEDOUT_INCAP_SHIELD_COLOR_FULL, vector medHealthColor = BLEEDOUT_INCAP_SHIELD_COLOR_MED, vector emptyHealthColor = BLEEDOUT_INCAP_SHIELD_COLOR_EMPTY )
{
	return GetTriLerpColor( chargeFrac, fullHealthColor, medHealthColor, emptyHealthColor )
}

// Copied from vortex, since it's not a global func
vector function GetTriLerpColor( float fraction, vector color1, vector color2, vector color3 )
{
	float crossover1 = 0.55  // from zero to this fraction, fade between color1 and color2
	float crossover2 = 0.75 // from crossover1 to this fraction, fade between color2 and color3

	float r, g, b

	// 0 = full charge, 1 = no charge remaining
	if ( fraction < crossover1 )
	{
		r = Graph( fraction, 0, crossover1, color1.x, color2.x )
		g = Graph( fraction, 0, crossover1, color1.y, color2.y )
		b = Graph( fraction, 0, crossover1, color1.z, color2.z )
		return <r, g, b>
	}
	else if ( fraction < crossover2 )
	{
		r = Graph( fraction, crossover1, crossover2, color2.x, color3.x )
		g = Graph( fraction, crossover1, crossover2, color2.y, color3.y )
		b = Graph( fraction, crossover1, crossover2, color2.z, color3.z )
		return <r, g, b>
	}
	else
	{
		// for the last bit of overload timer, keep it max danger color
		r = color3.x
		g = color3.y
		b = color3.z
		return <r, g, b>
	}

	unreachable
}

// why vortex_sphere don't have a damaged callback?
/*
void function IncapShieldTableUpdate( entity vortexSphere, var damageInfo )
{
	//print( "try to update incap shield health!" )
	entity owner = vortexSphere.GetOwner()
	if( !IsValid( owner ) )
		return
	float baseDamage = DamageInfo_GetDamage( damageInfo )
	float damageDifference = vortexSphere.GetHealth() - baseDamage
	if( baseDamage >= 300 ) // basically for krabers
		baseDamage = 300
	if( damageDifference < 0 ) // shield broke damage
	{
		owner.TakeDamage( fabs( damageDifference ), 
						  DamageInfo_GetAttacker( damageInfo ), 
						  DamageInfo_GetInflictor( damageInfo ), 
						  { // damage table
							weapon = DamageInfo_GetWeapon( damageInfo ), 
						    origin = DamageInfo_GetDamagePosition( damageInfo ), 
							force = DamageInfo_GetDamageForce( damageInfo ), 
							scriptType = DamageInfo_GetCustomDamageType( damageInfo ), 
							damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo ) 
						  } )
		file.incapShieldHealthTable[ owner ] = 0
		return
	}
	int calcDamage = file.incapShieldHealthTable[ owner ] - int( DamageInfo_GetDamage( damageInfo ) )
	file.incapShieldHealthTable[ owner ] = int( max( calcDamage, 0 ) )
	//print( "incap Shield health left: "+ string( file.incapShieldHealthTable[ owner ] ) )
}

void function TrackPlayerIncapShieldHealth( entity vortexSphere, entity player )
{
	vortexSphere.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function():( vortexSphere, player )
		{
			if( !IsValid( vortexSphere ) )
			{
				file.incapShieldHealthTable[ player ] = 0
				//print( "incap Shield down" )
			}
			if( IsValid( player ) )
			{
				file.incapShieldHealthTable[ player ] = file.incapShieldMaxHealth // restore shield
				if( Bleedout_IsPlayerBleeding( player ) && IsAlive( player ) ) // otherwise means player has been revived or died
					EmitSoundOnEntity( player, "ShieldWall_Destroyed" )
			}
		}
	)

	int lastTickHealth = vortexSphere.GetHealth()
	while( true )
	{
		int calcDamage = lastTickHealth - vortexSphere.GetHealth()
		file.incapShieldHealthTable[ player ] = int( max( file.incapShieldHealthTable[ player ] - calcDamage, 0 ) )

		lastTickHealth = vortexSphere.GetHealth()
		//print( "incap Shield health left: "+ string( file.incapShieldHealthTable[ player ] ) )
		WaitFrame()
	}
}
*/

void function Bleedout_ScreenFadeThink( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function(): ( player )
		{
			if( IsValid( player ) )
			{
				ScreenFade( player, 0, 0, 0, 125, 0.1, 0.1, FFADE_IN | FFADE_PURGE )
			}
		}
	)

	float bleedingTime = Bleedout_GetBleedoutTime()

	wait bleedingTime * 0.5
	
	ScreenFade( player, 0, 0, 0, 225, bleedingTime * 0.5, 999, FFADE_OUT | FFADE_PURGE )
	WaitForever()
}

void function Bleedout_FakePlayerThink( entity player ) // don't know how to do this
{
	float fadeDist 	= 10000.0
	int solidType = 0// 0 = no collision, 2 = bounding box, 6 = use vPhysics, 8 = hitboxes only

	player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
	entity fakePlayer = CreatePropDynamic( player.GetModelName(), < 0,0,0 >, < 0,0,0 >, solidType, fadeDist )
	fakePlayer.SetOwner( player )
	SetTeam( fakePlayer, player.GetTeam() )
	fakePlayer.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	entity mover = CreateScriptMover()
	mover.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
	mover.SetModel( $"models/dev/empty_model.mdl" )
	mover.SetParent( player, "ORIGIN" )
	mover.SetOrigin( < -35, 50, 0 > ) // redirect fake player
	SetForceDrawWhileParented( mover, true )
	fakePlayer.SetParent( mover, "REF" )
	file.bleedoutFakePlayers[ player ] = fakePlayer
	fakePlayer.Anim_Play( "pt_wounded_drag_zinger_A_idle" )
}

void function Bleedout_HealthRegenThink( entity player )
{
    player.EndSignal( "OnDestroy" )
	player.Signal( "BleedoutHealthRegenThink" ) // why this not getting registered most of time..
	player.Signal( "StopHealthRegenThink" ) // end normal health regen in _health_regen.gnut
	player.EndSignal( "BleedoutHealthRegenThink" )
	player.EndSignal( "StopHealthRegenThink" )

	float healthRegenStartDelay = file.bleedoutHealthRegenDelay

	while ( IsValid( player ) )
	{
		//print( "Bleedout Health Regen Think" )
		wait( HEALTH_REGEN_TICK_TIME )

		if ( !IsAlive( player ) )
			continue

		if ( !IsPilot( player ) )
			continue

		if ( shGlobal.proto_pilotHealthRegenDisabled )
			continue

		float healthRegenRate = file.bleedoutHealthRegenRate	// health regen per tick

		if ( player.GetHealth() == player.GetMaxHealth() )
			continue

		// No regen during phase shift
		if ( player.IsPhaseShifted() )
			continue

		// no regen during bleeding out
		if( Bleedout_IsPlayerBleeding( player ) )
			continue

		if ( Time() - player.p.lastDamageTime < healthRegenStartDelay )
		{
			continue
		}

		player.SetHealth( min( player.GetMaxHealth(), player.GetHealth() + healthRegenRate ) )
		if ( player.GetHealth() == player.GetMaxHealth() )
		{
			ClearRecentDamageHistory( player )
			ClearLastAttacker( player )
		}
	}
}

// settings goes here
void function Bleedout_EnableExecutingBleedingPlayer( bool enable )
{
	file.executingBleedingEnabled = enable
}

void function Bleedout_SetProtectionDuration( float duration )
{
	file.protectionDuration = duration
}

void function Bleedout_SetIncapShieldInvulnerable( bool invulnerable )
{
	file.invulnerableIncapShield = invulnerable
}

void function Bleedout_SetIncapShieldHealth( int health )
{
	file.incapShieldMaxHealth = health
}

void function Bleedout_SetHealthRegenRate( float rate )
{
	file.bleedoutHealthRegenRate = rate
}

void function Bleedout_SetHealthRegenDelay( float delay )
{
	file.bleedoutHealthRegenDelay = delay
}