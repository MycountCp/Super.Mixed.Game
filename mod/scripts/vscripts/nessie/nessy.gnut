untyped
global function EverythingNessy_Init
global function Nessy_EnableAllFunny_Init

global function SpawnNessyOutfit
global function AllFunctionsTogether
global function CreateNessyHat
global function CreateNessyBackpack
global function CreateNessyPistol
global function CreateNessyWeapon
global function CreateNessyFX
global function ClearNessy

global function Nessie_SetBatterySpawnEnabled
global function Nessie_SetFunnyFlagEnabled
global function Nessie_SetWorldMaxNessieCount
global function Nessie_AlwaysSpawnRGBStuff

global struct NessyHat
{
	asset modelasset
	entity hat
	entity owner
}
global struct NessyPack
{
	asset modelasset
	entity pack
	entity owner
}
global struct NessyPistol
{
	asset modelasset
	entity pistol
	entity owner
}
global struct NessyWeapon
{
	asset modelasset
	entity weapon
	entity owner
}
global struct NessyFX
{
	entity fx
	entity owner
}
global struct NessyMix
{
	array<asset> mixassets
	array<entity> fxhandles
	entity owner
}

const int MAX_NESSIE_COUNT = 64
const int MAX_FUNNY_FLAGS = 32

struct
{
	bool allSettingsEnabled = false

	bool batterySpawnEnabled = false
	bool flagSpawnEnabled = false
	array<entity> nessieDolls = []
	int worldMaxNessieCount = MAX_NESSIE_COUNT // default value
	array<entity> funnyFlags = []

	bool alwaysRGBSpawn = false // funny
} file

global const array<asset> placements = [$"models/domestic/nessy_doll.mdl", $"models/robots/drone_frag/drone_frag.mdl"]
global const array<asset> hatassets = [$"models/domestic/nessy_doll.mdl", $"models/robots/drone_frag/drone_frag.mdl", $"models/robots/marvin/marvin.mdl", $"models/creatures/prowler/r2_prowler.mdl", $"models/weapons/data_knife/v_data_knife.mdl"]
global const array<asset> backpackassets = [$"models/weapons/titan_sword/w_titan_sword_prime.mdl", $"models/weapons/titan_sword/w_titan_sword.mdl", $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl", $"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl", $"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl", $"models/weapons/titan_predator/w_titan_predator.mdl", $"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl", $"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl", $"models/weapons/thr_40mm/w_thr_40mm.mdl", $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"]
global const array<asset> pistolassets = [$"models/weapons/alternator_smg/w_alternator_smg.mdl", $"models/weapons/p2011_auto/w_p2011_auto.mdl", $"models/weapons/car101/w_car101.mdl", $"models/weapons/rspn101_dmr/w_rspn101_dmr.mdl", $"models/weapons/doubletake/w_doubletake.mdl", $"models/weapons/epg/w_epg.mdl", $"models/weapons/hemlock_br/w_hemlock_br.mdl", $"models/weapons/g2/w_g2a4.mdl", $"models/weapons/m1a1_hemlok/w_hemlok.mdl", $"models/weapons/hemlok_smg/w_hemlok_smg.mdl", $"models/weapons/lmg_hemlok/w_lmg_hemlok.mdl", $"models/weapons/lstar/w_lstar.mdl", $"models/weapons/mastiff_stgn/w_mastiff.mdl", $"models/weapons/pulse_lmg/w_pulse_lmg.mdl", $"models/weapons/rspn101/w_rspn101.mdl", $"models/weapons/r101_sfp/w_r101_sfp.mdl", $"models/weapons/p2011/w_p2011.mdl", $"models/weapons/w1128/w_w1128.mdl", $"models/weapons/pstl_sa3/w_pstl_sa3.mdl", $"models/weapons/p2011sp/w_p2011sp.mdl", $"models/weapons/auto_rocket_launcher_ARL/w_ARL.mdl", $"models/weapons/at_rifle/w_at_rifle.mdl", $"models/weapons/softball_at/w_softball_at.mdl", $"models/weapons/vinson/w_vinson.mdl", $"models/weapons/b3wing/w_b3wing.mdl", $"models/weapons/wingman_elite/w_wingman_elite.mdl"]
global const array<asset> fxassets = [$"P_wpn_arcball_trail", $"P_wpn_meteor_trail", $"P_titan_sniper1"]

global const array<asset> fxmixbase = [$"titan_sniper_CH_refract", $"titan_sniper_CH_refract", $"titan_sniper_CH_rope_smoke"]
global const array<asset> fxmixMLT = [$"P_proj_predator_alt_pwr", $"P_projectile_lstar"]
global const array<asset> fxmixIMC = [$"titan_sniper_CH_trail_arc", $"wpn_grenade_frag_blue", $"P_doubletake_proj", $"P_wpn_mflash_dbltake_FP_burn"]

global const array<string> batterySpawners = ["1007270968017"] // for every nessie script

array<NessyHat> nessyhats = []
array<NessyPack> nessybackpacks = []
array<NessyPistol> nessypistols = []
array<NessyWeapon> nessyweapons = []
array<NessyFX> nessyfxs = []
array<NessyMix> nessymixs = []
array<string> nessyedplayer = []
array<string> battedPlayer = []

int RAGDOLL_IMPACT_TABLE_IDX = -1

void function EverythingNessy_Init()
{
	PrecacheSelectedModels()
	PrecacheSelectedParticles()
	PrecacheParticleSystem( FLAG_FX_FRIENDLY )
	PrecacheParticleSystem( FLAG_FX_ENEMY )

	// following things needs a setting to enable
	if ( !file.allSettingsEnabled )
		return

	SetNessieDecoyOn( true ) // from mp_ability_holopilot.nut
	if ( Riff_TitanAvailability() == eTitanAvailability.Never )
	{
		Rodeo_SetBatterySkinRandom( true ) // from _rodeo_titan.gnut
		SetPilotBatteryUsageAllowed( true ) // from pilot_shield_battery.gnut
		SetShieldBatteryNoLimit( true ) // from pilot_shield_battery.gnut
	}
	//if( GAMETYPE != "mfd" ) //prevent mfd client crash, no need for now I've fixed it
	//{
		AddCallback_OnPlayerRespawned( OnPlayerRespawned )
		AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerChangeLoadout )
		AddCallback_OnPlayerKilled( OnPlayerKilled )
		AddCallback_OnPilotBecomesTitan( OnPilotBecomesTitan )
		AddCallback_OnTitanBecomesPilot( OnTitanBecomesPilot )
	//}

	if( IsNonFlagGamemode() )
	{
		AddCallback_OnTouchHealthKit( "item_flag", OnFlagCollected )
	}
	RAGDOLL_IMPACT_TABLE_IDX = PrecacheImpactEffectTable( "ragdoll_human" )
	// register things for ingame script
    if( GetGameState() >= eGameState.Prematch )
    {
        foreach( entity player in GetPlayerArray() )
            OnClientConnected( player )
    }
	AddCallback_OnClientConnected( OnClientConnected )
	// using _rodeo_titan.gnut for more fix about batteries
	AddClientCommandCallback( "spawnbatt", SpawnBattery )
	AddClientCommandCallback( "givebatt", GiveEmergencyBattery )
	AddClientCommandCallback( "clearbatt", ClearBattery )
	//AddClientCommandCallback( "rgbnessie", SpawnRGBNessie ) // use a funnier nessie check
}

void function Nessy_EnableAllFunny_Init()
{
	file.allSettingsEnabled = true
}

void function Nessie_AlwaysSpawnRGBStuff( bool always )
{
	file.alwaysRGBSpawn = always
}

bool function IsNonFlagGamemode()
{
	if( GAMETYPE == "ctf" || GAMETYPE == "speedball" || GAMETYPE == "kr" )
		return false

	return true
}

bool function OnFlagCollected( entity player, entity flag )
{
	if ( !IsAlive( player ) || flag.GetParent() != null || player.IsTitan() || player.IsPhaseShifted() ) 
		return false

	//if ( player.GetTeam() != flag.GetTeam() && !expect bool( player.s.hasFlag ) ) 
	// no team check
	if ( !expect bool( player.s.hasFlag ) )
		thread CarryFlag( player, flag ) // pickup enemy flag

	return false // don't wanna delete the flag entity
}

void function CarryFlag( entity player, entity flag )
{
	print( player + " picked up the flag!" )

	flag.SetParent( player, "FLAG" )
	player.s.hasFlag = true
	player.EndSignal( "StartPhaseShift" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	// abandoned for now, keep showing the flag fx!
	//flag.SetOwner( player ) // stop fx for carrier
	//FunnyFlag_StopFX( flag )
	//entity curFlagFX = expect entity( flag.s.fxToHide )
	//if( IsValid( curFlagFX ) )
	//	curFlagFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	//entity newFX = FunnyFlag_StartRandomFX( flag )
	//newFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY
	
	OnThreadEnd(
		function():( player, flag )
		{
			if( IsValid( flag ) )
			{
				flag.ClearParent()
				flag.SetOwner( null )
				flag.SetAngles( < 0, 0, 0 > )
				flag.SetVelocity( < 0, 0, 0 > )
				// abandoned for now, keep showing the flag fx!
				//FunnyFlag_StopFX( flag )
				//FunnyFlag_StartRandomFX( flag )
			}
			if( IsValid( player ) )
			{
				EmitSoundOnEntityOnlyToPlayer( player, player, "UI_CTF_1P_FlagDrop" )
				player.s.hasFlag = false
			}
		}
	)

	// do notifications
	EmitSoundOnEntityOnlyToPlayer( player, player, "UI_CTF_1P_GrabFlag" )
	AddPlayerScore( player, "FlagTaken" )

	WaitForever()
}

void function CallbackFuncSpawnFlag( entity player )
{
	if( !IsNonFlagGamemode() )
		return
	if( !file.flagSpawnEnabled )
		return
	if( !GamePlaying() )
		return
	if( IsValid( player.GetOffhandWeapon( OFFHAND_ANTIRODEO ) ) )
		return
	entity flag = CreateFunnyFlag( player )
	if( flag )
	{
		flag.SetVelocity( player.GetViewVector() * 1000 )
	}
}

void function Nessie_SetFunnyFlagEnabled( bool enabled )
{
	file.flagSpawnEnabled = enabled
}

entity function CreateFunnyFlag( entity player )
{
	// create flag
	entity flag = CreateEntity( "item_flag" )
	flag.SetValueForModelKey( CTF_FLAG_MODEL )
	flag.SetModel( CTF_FLAG_MODEL )
	SetTeam( flag, player.GetTeam() ) // don't set a team if want to make player himself can't see the fx
	flag.MarkAsNonMovingAttachment()
	//flag.Minimap_AlwaysShow( TEAM_IMC, null ) // show flag icon on minimap, for funny flags I say no need
	//flag.Minimap_AlwaysShow( TEAM_MILITIA, null )
	flag.Minimap_Hide( TEAM_IMC, null )
	flag.Minimap_Hide( TEAM_MILITIA, null )
	flag.Minimap_SetAlignUpright( true )
	FunnyFlag_StartRandomFX( flag )
	// abandoned for now, keep showing the flag fx!
	//entity randomFX
	//if( CoinFlip() )
	//	randomFX = PlayFXOnEntity( FLAG_FX_FRIENDLY, flag, "fx_end" )//StartParticleEffectOnEntity_ReturnEntity( flag, GetParticleSystemIndex( FLAG_FX_FRIENDLY ), FX_PATTACH_POINT_FOLLOW, attachID )
	//else
	//	randomFX = PlayFXOnEntity( FLAG_FX_ENEMY, flag, "fx_end" )//StartParticleEffectOnEntity_ReturnEntity( flag, GetParticleSystemIndex( FLAG_FX_ENEMY ), FX_PATTACH_POINT_FOLLOW, attachID )
	//flag.s.fxToHide <- randomFX
	DispatchSpawn( flag )
	flag.SetModel( CTF_FLAG_MODEL )
	flag.SetOrigin( player.EyePosition() ) // ensure flag doesn't spawn clipped into geometry
	int attachID = flag.LookupAttachment( "fx_end" )
	//flag.SetVelocity( < 0, 0, 1 > )
	
	file.funnyFlags.append( flag )
	CheckFunnyFlagsLimit()

	return flag
}

entity function FunnyFlag_StartRandomFX( entity flag )
{
	entity flagFX
	if( CoinFlip() )
	{
		flagFX = PlayLoopFXOnEntity( FLAG_FX_FRIENDLY, flag, "fx_end" )
		//flagFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	}
	else
	{
		flagFX = PlayLoopFXOnEntity( FLAG_FX_ENEMY, flag, "fx_end" )
		//flagFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	}
	flag.e.fxArray.append( flagFX )

	return flagFX
}

void function FunnyFlag_StopFX( entity flag )
{
	foreach( entity fx in flag.e.fxArray )
	{
		if( IsValid( fx ) )
			EffectStop( fx )
	}

	flag.e.fxArray.clear()
}

void function CheckFunnyFlagsLimit()
{
	if( file.funnyFlags.len() > MAX_FUNNY_FLAGS )
	{
		for( int i = 0; i < file.funnyFlags.len() - 1; i++ )
		{
			if( !IsValid( file.funnyFlags[i] ) )
			{
				file.funnyFlags.remove( i )
				continue
			}
			if( file.funnyFlags[i].GetParent() ) // assuming this is a flag carried by players
				continue
			file.funnyFlags[i].Destroy()
			break
		}
	}
}

void function OnClientConnected( entity player )
{
	player.s.hasFlag <- false
	AddButtonPressedPlayerInputCallback( player, IN_USE, CallbackFuncSpawnNessy )
	AddButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, CallbackFuncSpawnNessy )
	AddButtonPressedPlayerInputCallback( player, IN_MELEE, CallbackFuncSpawnBattery )
	AddButtonPressedPlayerInputCallback( player, IN_OFFHAND2, CallbackFuncSpawnFlag )
	//AddButtonPressedPlayerInputCallback( player, IN_MELEE, CallbackFuncSpawnRagdoll )
}

void function OnPlayerRespawned( entity player )
{
	//thread SpawnNessyOutfit( player ) // OnPlayerGetsNewPilotLoadout also called after respawn, no need
}

void function OnPlayerChangeLoadout( entity player, PilotLoadoutDef p )
{
	ClearNessy( player )
	thread SpawnNessyOutfit( player )
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
	ClearNessy( victim )
}

void function OnPilotBecomesTitan( entity player, entity titan )
{
	ClearNessy( player )
}

void function OnTitanBecomesPilot( entity titan, entity player )
{
	ClearNessy( player )
	thread SpawnNessyOutfit( player )
}

void function PrecacheSelectedModels()
{
	foreach( asset model in placements )
	{
		PrecacheModel( model )
	}
	foreach( asset model in hatassets )
	{
		PrecacheModel( model )
	}
	foreach( asset model in backpackassets )
	{
		PrecacheModel( model )
	}
}

void function PrecacheSelectedParticles()
{
	foreach( asset particle in fxassets )
	{
		PrecacheParticleSystem( particle )
	}
	foreach( asset particle in fxmixbase )
	{
		PrecacheParticleSystem( particle )
	}
	foreach( asset particle in fxmixMLT )
	{
		PrecacheParticleSystem( particle )
	}
	foreach( asset particle in fxmixIMC )
	{
		PrecacheParticleSystem( particle )
	}
}

void function SpawnNessyOutfit( entity player )
{
	ClearNessy( player ) // defensive clear!
	WaitFrame() // better wait since we have "altpilot"
	if( !IsAlive( player ) )
		return
	if( !player.IsTitan() )
	{
		//AllFunctionsTogether( player )
		CreateNessyHat( hatassets, player )
		CreateNessyBackpack( backpackassets, player )
		//CreateNessyFX( fxassets, player )
		//CreateNessyPistol( pistolassets, player )
	}
}

bool function SpawnBattery( entity player, array<string> args )
{
	// no battery spawn allowed in titan Gamemodes
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return false
	//if( !batterySpawners.contains( player.GetUID() ) )
		//return false
	if( !file.batterySpawnEnabled )
		return false
	if( !GamePlaying() )
		return false

	if( !(args.len() == 0) )
	{
		bool isPickup = false
		bool isThrow = false
		if( args.contains( "pickup" ) )
			isPickup = true
		if( args.contains( "throw" ) )
			isThrow = true
		
		entity battery = Rodeo_CreateBatteryPack( player, isPickup, true )
		if( isThrow )
		{
			if( battery )
			{
				vector batteryVel = player.GetViewVector() * 1000
				battery.SetVelocity( batteryVel )
				//battery.kv.CollisionGroup = TRACE_COLLISION_GROUP_NONE
			}
		}
		print( "[NESSIE] " + player.GetPlayerName() + " modified spawning a battery!" )
	}
	else
	{
		Rodeo_CreateBatteryPack( player )
		print( "[NESSIE] " + player.GetPlayerName() + " spawned a battery!" )
	}

	return true
}

bool function GiveEmergencyBattery( entity player, array<string> args )
{
	// no battery spawn allowed in titan Gamemodes
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return false
	if( !batterySpawners.contains( player.GetUID() ) )
		return false
	if( !GamePlaying() )
		return false

	PlayerInventory_PushInventoryItemByBurnRef( player, "burnmeter_emergency_battery" )
	print( "[NESSIE] " + player.GetPlayerName() + " give themselves an emergency battery!" )
	return true
}

bool function ClearBattery( entity player, array<string> args )
{
	if( !batterySpawners.contains( player.GetUID() ) )
		return false
	if( !GamePlaying() )
		return false

	foreach ( entity battery in GetEntArrayByClass_Expensive( "item_titan_battery" ) )
		battery.Destroy() // there's some fix in _rodeo_titan.gnut
	foreach( entity player in GetPlayerArray() )
	{
		while( GetPlayerBatteryCount( player ) > 0 )
		{
			entity battery = Rodeo_TakeBatteryAwayFromPilot( player )
			if( IsValid( battery ) )
				battery.Destroy()
		}
	}

	PilotBattery_SetMaxCount( 1 )
	print( "[NESSIE] " + player.GetPlayerName() + " cleared all batteries!" )
	
	return true
}

bool function SpawnRGBNessie( entity player, array<string> args )
{
	entity Prop = CreateEntity( "prop_dynamic" )
	Prop.SetValueForModelKey( $"models/domestic/nessy_doll.mdl" )
	Prop.kv.rendercolor = "81 130 151"   
	vector angles = player.EyeAngles()
	vector origin = GetPlayerCrosshairOrigin( player )
	angles.x = 0;
	angles.y += 90
	angles.z = 0;
	origin.z += -30
	Prop.SetOrigin( origin )
	Prop.SetAngles( angles )
	DispatchSpawn( Prop )
	SetTeam( Prop, player.GetTeam() )
	thread RGB_Hightlight( Prop, true )
	file.nessieDolls.append( Prop )

	NessieLimitThink()
	return true
}

void function CallbackFuncSpawnNessy( entity player )
{
	// for rgb nessie check
	bool badCombo = ((player.IsInputCommandHeld( IN_DUCKTOGGLE ) || player.IsInputCommandHeld( IN_DUCK )) && player.IsInputCommandHeld( IN_SPEED ) && ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) && player.IsInputCommandHeld( IN_ATTACK ))
	bool goodCombo = (( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) && player.IsInputCommandHeld( IN_JUMP ) && player.IsInputCommandHeld( IN_BACK ) && player.IsInputCommandHeld( IN_MELEE ))
	bool isMoving = ( player.IsSliding() || player.IsWallRunning() || !player.IsOnGround() ) && !player.IsZiplining()
	//print( badCombo )
	//print( goodCombo )

	// nessie spawning has no limit, and nessie only!
	//asset spawnAsset = placements[ RandomInt(placements.len()) ]
	//nessie.SetValueForModelKey( spawnAsset )
	//if( spawnAsset == $"models/creatures/prowler/r2_prowler.mdl" )
	//	nessie.kv.modelscale = 0.2
	//else
	//	nessie.kv.modelscale = 0.4
	//if( spawnAsset == $"models/domestic/nessy_doll.mdl" )
	//	angles.y += 90
	//else
	//	angles.y -= 180

	entity nessie = CreateEntity( "prop_dynamic" )
	nessie.SetValueForModelKey( $"models/domestic/nessy_doll.mdl" )
	//nessie.kv.rendercolor = "81 130 151"   
	
	SetTeam( nessie, player.GetTeam() )
	if( isMoving )
	{
		entity physics = CreateEntity( "prop_physics" )
		physics.SetValueForModelKey( $"models/dev/empty_physics.mdl" )
        physics.SetOrigin( player.EyePosition() + player.GetViewVector() * 100 + < 0,0,40 > ) // don't spawn so close, or it will interrupt zipline
		physics.SetAngles( < 0, player.EyeAngles().y, 0 > )
		physics.kv.spawnflags = 4 // 4 = SF_PHYSPROP_DEBRIS
		physics.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS // cannot block weapons, not work why?
		DispatchSpawn( physics )
		physics.SetModel( $"models/dev/empty_physics.mdl" )
		physics.SetVelocity( player.GetViewVector() * 1000 )
		nessie.SetParent( physics, "origin" )
		nessie.SetAngles( < 0, -90, 0 > )
		thread NessiePhysicsLifeTimeCheck( physics, nessie )
	}
	else
	{
		vector angles = player.EyeAngles()
		vector origin = GetPlayerCrosshairOrigin( player )
		//nessie.kv.modelscale = 50
		//Highlight_SetFriendlyHighlight( nessie, "health_pickup" )
		angles.x = 0
		angles.y += 90
		// defensive fix!!!
		if( angles.y > 360.0 )
			angles.y = -360 + ( angles.y - 360 )
		else if( angles.y < -360.0 )
			angles.y = 360 - fabs( angles.y + 360 )
		//print( angles.y )
		angles.z = 0
		origin.z += -30
		nessie.SetOrigin( origin )
		nessie.SetAngles( angles )
	}
	DispatchSpawn( nessie )

	if( badCombo || file.alwaysRGBSpawn )
		thread RGB_Hightlight( nessie, true )
	if( goodCombo )
	{
		EmitSoundOnEntityOnlyToPlayer( player, player, "UI_Spawn_FriendlyPilot" )
		thread RainbowPlayerSkin( player )
		thread RainbowWeaponSkin( player )
	}

	file.nessieDolls.append( nessie )

	//thread DelayedDissolveNessie( nessie )
	NessieLimitThink()
}

void function Nessie_SetWorldMaxNessieCount( int count )
{
	file.worldMaxNessieCount = count
}

void function CallbackFuncSpawnBattery( entity player )
{
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return
	if( !file.batterySpawnEnabled )
		return
	if( !battedPlayer.contains(player.GetUID()) )
	{
		entity battery = Rodeo_CreateBatteryPack( player, false, true )
		bool badCombo = ((player.IsInputCommandHeld( IN_DUCKTOGGLE ) || player.IsInputCommandHeld( IN_DUCK )) && player.IsInputCommandHeld( IN_SPEED ) && ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) && player.IsInputCommandHeld( IN_ATTACK ))
		if( battery )
		{
			// never blocks bullet, but also unable to stack batteries
			//battery.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS 
			vector batteryVel = player.GetViewVector() * 1000
			battery.SetVelocity( batteryVel )
			if( badCombo || file.alwaysRGBSpawn )
				thread RGY_BatterySkin( battery )
			//battery.kv.CollisionGroup = TRACE_COLLISION_GROUP_NONE
		}
		/*
		if( !batterySpawners.contains( player.GetUID() ) )
		{
			battedPlayer.append( player.GetUID() ) 
			thread ClearBattedPlayer( player )
		}
		*/
	}
	else
		return
}

void function Nessie_SetBatterySpawnEnabled( bool enabled )
{
	file.batterySpawnEnabled = enabled
}

void function CallbackFuncSpawnRagdoll( entity player )
{
	thread SpawnRagdoll_Threaded( player )
}

void function SpawnRagdoll_Threaded( entity player )
{
	entity copyModel = player.CreatePlayerDecoy( 1 )//CreateCopyOfPlayerModel( player )
	vector curVelocity = player.GetVelocity()
	copyModel.EndSignal( "OnDestroy" )
	OnThreadEnd(
		function(): ()
		{
			print( "Copy Model has been destroyed!" )
		}
	)
	copyModel.SetOrigin( player.GetOrigin() )
	copyModel.SetAngles( player.GetAngles() )
	wait 0.2
	copyModel.Anim_Play( "ACT_MP_MELEE_KNIFE_FIRST" )
	//copyModel.BecomeRagdoll( < 0,0,0 >, false )
	HideName( copyModel )
	WaitForever()
	//copyModel.SetActivityModifier( ACT_MODIFIER_STAGGER, true ) // not for a propDynamic
	//wait 2
	//copyModel.SetRagdollImpactFX( RAGDOLL_IMPACT_TABLE_IDX )
	//copyModel.SetContinueAnimatingAfterRagdoll( true )
	//
}

entity function CreateCopyOfPlayerModel( entity player )
{
	entity model = CreatePropDynamic( player.GetModelName() )

	SetTeam( model, player.GetTeam() )

	//model.SetSkin( player.GetSkin() )
	//model.SetCamo( player.GetCamo() )

	//RandomizeHead( model )

	return model
}

void function ClearNessyedPlayer( entity player )
{
	string uid = player.GetUID()
	wait 3
	if( IsValid( player ) )
		nessyedplayer.removebyvalue( uid )	
}

void function ClearBattedPlayer( entity player )
{
	string uid = player.GetUID()
	wait 3
	if( IsValid( player ) )
		nessyedplayer.removebyvalue( uid )	
}

void function DelayedDissolveNessie( entity nessy )
{
	wait 10
	if( IsValid( nessy ) )
		nessy.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
}

void function NessieLimitThink()
{
	if( file.nessieDolls.len() > file.worldMaxNessieCount )
	{
		if( IsValid( file.nessieDolls[0] ) )
			file.nessieDolls[0].Destroy()
		file.nessieDolls.remove(0)
	}
}

void function NessiePhysicsLifeTimeCheck( entity physics, entity nessie )
{
	nessie.EndSignal( "OnDestroy" )
	physics.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( nessie, physics )
		{
			if( IsValid( nessie ) )
				nessie.Destroy()
			if( IsValid( physics ) )
				physics.Destroy()
		}
	)

	WaitForever()
}

void function AllFunctionsTogether( entity player )
{
	CreateNessyHat( hatassets, player )
	CreateNessyBackpack( backpackassets, player )
	CreateNessyPistol( pistolassets, player )
	CreateNessyWeapon( pistolassets, player )
	if( IsFFAGame() )
		CreateNessyFX( fxassets, player )
	else
		CreateMixedNessyFX( fxmixbase, fxmixMLT, fxmixIMC, player )
}

void function CreateNessyHat( array<asset> modelassets, entity player )
{
	NessyHat nessy
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.hat = CreateEntity( "prop_dynamic" )
	nessy.hat.SetModel( nessy.modelasset )
	nessy.owner = player
	nessy.hat.SetParent( nessy.owner, "HEADSHOT" )
	nessy.hat.Highlight_SetInheritHighlight( true )
	SetNessyHatStats( nessy )
	nessyhats.append(nessy)
}

void function SetNessyHatStats( NessyHat nessy )
{
	if ( CanRemoveHead( nessy.owner ) )
	{
		if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 1 )
			nessy.hat.SetOrigin( < 0, 0, -10 > )
			nessy.hat.SetAngles( < 0, -90, 0 > )
			return
		}
		if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 1 )
			nessy.hat.SetOrigin( < 0, 0, -15 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/robots/marvin/marvin.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 1 )
			nessy.hat.SetOrigin( < -5, 0, -25 > )
			nessy.hat.kv.modelscale = 0.4
			return
		}
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 3 > )
			nessy.hat.kv.modelscale = 0.15
			return
		}
		/*
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -25 > )
			nessy.hat.SetAngles( < -90, 0, 0 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		*/
		if( nessy.modelasset == $"models/weapons/data_knife/v_data_knife.mdl" )
		{
			nessy.hat.SetOrigin( < 2, 0, 7 > )
			nessy.hat.SetAngles( < 0, 0, 0 > )
			return
		}
	}
	else if( CannotRemoveHelmet( nessy.owner ) )
	{
		if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 0 > )
			return
		}
		if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -3 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/robots/marvin/marvin.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -10 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 3 > )
			nessy.hat.kv.modelscale = 0.15
			return
		}
		if( nessy.modelasset == $"models/weapons/data_knife/v_data_knife.mdl" )
		{
			nessy.hat.SetOrigin( < 2, 0, 7 > )
			nessy.hat.SetAngles( < 0, 0, 0 > )
			return
		}
	}
	else if( HasFlatHead( nessy.owner ) )
	{
		if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 0 > )
			return
		}
		if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -5 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/robots/marvin/marvin.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -12 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 1 > )
			nessy.hat.kv.modelscale = 0.15
			return
		}
		if( nessy.modelasset == $"models/weapons/data_knife/v_data_knife.mdl" )
		{
			nessy.hat.SetOrigin( < 2, 0, 5 > )
			nessy.hat.SetAngles( < 0, 0, 0 > )
			return
		}
	}
	else
	{
		if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 0 > )
			return
		}
		if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 1 )
			nessy.hat.SetOrigin( < 0, 0, -3 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/robots/marvin/marvin.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -10 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 3 > )
			nessy.hat.kv.modelscale = 0.15
			return
		}
		if( nessy.modelasset == $"models/weapons/data_knife/v_data_knife.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 1 )
			nessy.hat.SetOrigin( < 2, 0, 7 > )
			nessy.hat.SetAngles( < 0, 0, 0 > )
			return
		}
	}
}

void function CreateNessyBackpack( array<asset> modelassets, entity player )
{
	NessyPack nessy
	nessy.owner = player
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.pack = CreateEntity( "prop_dynamic" )
	nessy.pack.SetModel( nessy.modelasset )
	nessy.pack.SetParent( nessy.owner, "CHESTFOCUS" )
	nessy.pack.Highlight_SetInheritHighlight( true )
	SetNessyBackpackStats( nessy )
	nessybackpacks.append(nessy)
}

void function SetNessyBackpackStats( NessyPack nessy )
{
	if( HasBigBackpack( nessy.owner ) )
	{
		if( nessy.modelasset == $"models/weapons/titan_sword/w_titan_sword_prime.mdl" || nessy.modelasset == $"models/weapons/titan_sword/w_titan_sword.mdl" )
		{
			switch( RandomInt(2) )
			{
				case 0:
					nessy.pack.SetOrigin( < -14, 10, 10 > )
					nessy.pack.SetAngles( < -135, 90, 0 > )
					break
				case 1:
					nessy.pack.SetOrigin( < -7, 8, 3 > )
					nessy.pack.SetAngles( < 180, 0, 0 > )
					break
			}
			nessy.pack.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl" )
		{
			switch( RandomInt(2) )
			{
				case 0:
					nessy.pack.SetOrigin( < -13, 8, 8 > )
					nessy.pack.SetAngles( < 135, 90, 0 > )
					break
				case 1:
					nessy.pack.SetOrigin( < -8, 8, 6 > )
					nessy.pack.SetAngles( < 90, 0, 180 > )
					break
			}
			nessy.pack.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl" )
		{
			nessy.pack.SetOrigin( < -13, 8, 8 > )
			nessy.pack.SetAngles( < 135, 90, 0 > )
			nessy.pack.kv.modelscale = 0.3
			return
		}
		else
		{
			nessy.pack.SetOrigin( < -15, 10, 10 > )
			nessy.pack.SetAngles( < 135, 90, 0 > )
			nessy.pack.kv.modelscale = 0.3
			return
		}
	}
	else
	{
		if( nessy.modelasset == $"models/weapons/titan_sword/w_titan_sword_prime.mdl" || nessy.modelasset == $"models/weapons/titan_sword/w_titan_sword.mdl" )
		{
			switch( RandomInt(2) )
			{
				case 0:
					if( IsHeavyPilot( nessy.owner ) || HasSmallBackpack( nessy.owner ) )
					{
						nessy.pack.SetOrigin( < -10, 10, 10 > )
						nessy.pack.SetAngles( < -135, 90, 0 > )
						break
					}
					else
					{
						nessy.pack.SetOrigin( < -8, 10, 10 > )
						nessy.pack.SetAngles( < -135, 90, 0 > )
						break
					}
				case 1:
					if( IsHeavyPilot( nessy.owner ) )
					{
						nessy.pack.SetOrigin( < -5, 10, 3 > )
						nessy.pack.SetAngles( < 180, 0, 0 > )
						break
					}
					if( IsLightPilot( nessy.owner ) )
					{
						nessy.pack.SetOrigin( < -4, 8, 3 > )
						nessy.pack.SetAngles( < 180, 0, 0 > )
						break
					}
					else
					{
						nessy.pack.SetOrigin( < -7, 8, 3 > )
						nessy.pack.SetAngles( < 180, 0, 0 > )
						break
					}
			}
			nessy.pack.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl" )
		{
			switch( RandomInt(2) )
			{
				case 0:
					nessy.pack.SetOrigin( < -8, 8, 8 > )
					nessy.pack.SetAngles( < 135, 90, 0 > )
					break
				case 1:
					if( IsHeavyPilot( nessy.owner ) )
					{
						nessy.pack.SetOrigin( < -8, 10, 6 > )
						nessy.pack.SetAngles( < 90, 0, 180 > )
						break
					}
					else
					{
						nessy.pack.SetOrigin( < -8, 7, 6 > )
						nessy.pack.SetAngles( < 90, 0, 180 > )
						break
					}
			}
			nessy.pack.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl" )
		{
			nessy.pack.SetOrigin( < -8, 8, 8 > )
			nessy.pack.SetAngles( < 135, 90, 0 > )
			nessy.pack.kv.modelscale = 0.3
			return
		}
		else
		{
			nessy.pack.SetOrigin( < -10, 10, 10 > )
			nessy.pack.SetAngles( < 135, 90, 0 > )
			nessy.pack.kv.modelscale = 0.3
			return
		}
	}
}

void function CreateNessyPistol( array<asset> modelassets, entity player )
{
	NessyPistol nessy
	nessy.owner = player
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.pistol = CreateEntity( "prop_dynamic" )
	nessy.pistol.SetModel( nessy.modelasset )
	nessy.pistol.SetParent( nessy.owner, "SIDEARM_HOLSTER" )
	nessy.pistol.Highlight_SetInheritHighlight( true )
	SetNessyPistolStats( nessy )
	nessypistols.append(nessy)
}

void function SetNessyPistolStats( NessyPistol nessy )
{
	nessy.pistol.SetOrigin( < 0, 0, 0 > )
	nessy.pistol.SetAngles( < 0, 0, 0 > )
	if( IsPilotPistol( nessy.modelasset ) )
	{
		nessy.pistol.kv.modelscale = 1.2
		return
	}
	else
	{
		nessy.pistol.kv.modelscale = 0.7
		return
	}
}

void function CreateNessyWeapon( array<asset> modelassets, entity player )
{
	NessyWeapon nessy
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.weapon = CreateEntity( "prop_dynamic" )
	nessy.weapon.SetModel( nessy.modelasset )
	nessy.owner = player
	nessy.weapon.SetParent( nessy.owner, "PROPGUN" )
	nessy.weapon.Highlight_SetInheritHighlight( true )
	SetNessyWeaponStats( nessy )
	nessyweapons.append(nessy)
}

void function SetNessyWeaponStats( NessyWeapon nessy )
{
	if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
	{
		nessy.weapon.SetOrigin( <10, 0, 0> )
		return
	}
	if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
	{
		nessy.weapon.SetOrigin( <10, 0, -5> )
		nessy.weapon.kv.modelscale = 0.3
		return
	}
}

void function CreateNessyFX( array<asset> fxassets, entity player )
{
	NessyFX nessy
	asset fxasset = fxassets[ RandomInt(fxassets.len()) ]
	nessy.owner = player
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )

	nessy.fx = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( fxasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
	nessy.fx.SetOwner( nessy.owner )
	nessy.fx.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only

	nessyfxs.append(nessy)
}

void function CreateMixedNessyFX( array<asset> mixbase, array<asset> mixmlt, array<asset> miximc, entity player )
{
	NessyMix nessy
	nessy.owner = player
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )

	foreach( asset baseasset in mixbase )
	{
		entity handle = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( baseasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		handle.SetOwner( nessy.owner )
		handle.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only
		nessy.fxhandles.append( handle )
	}
	if( player.GetTeam() == TEAM_MILITIA )
	{
		foreach( asset mltasset in mixmlt )
		{
			entity handle = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( mltasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
			handle.SetOwner( nessy.owner )
			handle.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only
			nessy.fxhandles.append( handle )
		}
	}
	if( player.GetTeam() == TEAM_IMC )
	{
		foreach( asset imcasset in miximc )
		{
			entity handle = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( imcasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
			handle.SetOwner( nessy.owner )
			handle.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only
			nessy.fxhandles.append( handle )
		}
	}
	nessymixs.append(nessy)
}

void function ClearNessy( entity player )
{
	foreach( NessyHat nessy in nessyhats )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.hat ) )
			{
				nessy.hat.Destroy()
				//nessy.hat.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
				nessyhats.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyPack nessy in nessybackpacks )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.pack ) )
			{
				nessy.pack.Destroy()
				//nessy.pack.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
				nessybackpacks.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyPistol nessy in nessypistols )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.pistol ) )
			{
				nessy.pistol.Destroy()
				//nessy.pistol.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
				nessypistols.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyWeapon nessy in nessyweapons )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.weapon ) )
			{
				nessy.weapon.Destroy()
				//nessy.weapon.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
				nessyweapons.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyFX nessy in nessyfxs )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.fx ) )
			{
				EffectStop( nessy.fx )
				nessyfxs.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyMix nessy in nessymixs )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.fxhandles ) )
			{
				foreach( entity handle in nessy.fxhandles )
				{
					if( IsValid(handle) )
						EffectStop( handle )
				}
				nessymixs.removebyvalue( nessy )
			}
		}
	}
}

bool function IsHeavyPilot( entity player )
{
	if( player.GetModelName() == $"models/humans/pilots/pilot_heavy_drex_m.mdl" ||
		player.GetModelName() == $"models/humans/pilots/pilot_heavy_drex_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_heavy_roog_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_heavy_roog_m.mdl" || 
		player.GetModelName() == $"models/humans/grunts/imc_grunt_shield_captain.mdl" )
		return true

	return false
}

bool function IsLightPilot( entity player )
{
	if( player.GetModelName() == $"models/Humans/heroes/imc_hero_blisk.mdl" || 
		player.GetModelName() == $"models/Humans/heroes/imc_hero_ash.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_ged_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_ged_m.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_medium_reaper_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/sp_medium_geist_f.mdl" || 
		player.GetModelName() == $"models/humans/heroes/mlt_hero_sarah.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_jester_f.mdl" )
		return true

	return false
}

bool function HasBigBackpack( entity player )
{
	if( player.GetModelName() == $"models/humans/pilots/pilot_light_jester_m.mdl" || 
		player.GetModelName() == $"models/humans/grunts/mlt_grunt_lmg.mdl" ||
		player.GetModelName() == $"models/robots/spectre/imc_spectre.mdl" )
		return true

	return false
}

bool function HasSmallBackpack( entity player )
{
	if( player.GetModelName() == $"models/humans/heroes/mlt_hero_jack.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_ged_m.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_jester_f.mdl" )
		return true

	return false
}

bool function CanRemoveHead( entity player )
{
	if( player.GetModelName() == $"models/humans/pilots/pilot_light_ged_m.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_ged_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_jester_m.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_jester_f.mdl" )
		return true

	return false
}

bool function CannotRemoveHelmet( entity player )
{
	if( player.GetModelName() == $"models/humans/heroes/mlt_hero_sarah.mdl" || 
		player.GetModelName() == $"models/Humans/heroes/imc_hero_blisk.mdl" || 
		player.GetModelName() == $"models/Humans/heroes/imc_hero_ash.mdl" )
		return true

	return false
}

bool function HasFlatHead( entity player )
{
	if( player.GetModelName() == $"models/robots/spectre/imc_spectre.mdl" )
		return true

	return false
}

bool function IsPilotWeapon( asset model )
{
	if( [$"models/weapons/alternator_smg/w_alternator_smg.mdl", $"models/weapons/p2011_auto/w_p2011_auto.mdl", $"models/weapons/car101/w_car101.mdl", $"models/weapons/rspn101_dmr/w_rspn101_dmr.mdl", $"models/weapons/doubletake/w_doubletake.mdl", $"models/weapons/epg/w_epg.mdl", $"models/weapons/hemlock_br/w_hemlock_br.mdl", $"models/weapons/g2/w_g2a4.mdl", $"models/weapons/m1a1_hemlok/w_hemlok.mdl", $"models/weapons/hemlok_smg/w_hemlok_smg.mdl", $"models/weapons/lmg_hemlok/w_lmg_hemlok.mdl", $"models/weapons/lstar/w_lstar.mdl", $"models/weapons/mastiff_stgn/w_mastiff.mdl", $"models/weapons/pulse_lmg/w_pulse_lmg.mdl", $"models/weapons/rspn101/w_rspn101.mdl", $"models/weapons/r101_sfp/w_r101_sfp.mdl", $"models/weapons/p2011/w_p2011.mdl", $"models/weapons/w1128/w_w1128.mdl", $"models/weapons/pstl_sa3/w_pstl_sa3.mdl", $"models/weapons/p2011sp/w_p2011sp.mdl", $"models/weapons/auto_rocket_launcher_ARL/w_ARL.mdl", $"models/weapons/at_rifle/w_at_rifle.mdl", $"models/weapons/softball_at/w_softball_at.mdl", $"models/weapons/vinson/w_vinson.mdl", $"models/weapons/b3wing/w_b3wing.mdl", $"models/weapons/wingman_elite/w_wingman_elite.mdl"].contains( model ) )
		return true

	return false
}

bool function IsPilotPistol( asset model )
{
	if( [$"models/weapons/b3wing/w_b3wing.mdl", $"models/weapons/wingman_elite/w_wingman_elite.mdl", $"models/weapons/p2011/w_p2011.mdl", $"models/weapons/p2011_auto/w_p2011_auto.mdl", $"models/weapons/pstl_sa3/w_pstl_sa3.mdl"].contains( model ) )
		return true

	return false
}

bool function IsTitanWeapon( asset model )
{
	if( [$"models/weapons/titan_sword/w_titan_sword_prime.mdl", $"models/weapons/titan_sword/w_titan_sword.mdl", $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl", $"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl", $"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl", $"models/weapons/titan_predator/w_titan_predator.mdl", $"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl", $"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl", $"models/weapons/thr_40mm/w_thr_40mm.mdl", $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"].contains( model ) )
		return true

	return false
}