untyped
global function NessieDebug_Init
//global function DebugParticle

//global function SpawnHoloPulseAtPosition
//global function SpawnWeaponEntity_CountLifeTime
//global function PlayAnimGestureFromScript
//global function CreateViewEntityForPlayer
//global function StartTitanShieldHealthRegen

//global function TTF1_WeaponUsage
//global function CreatePeteMri
//global function CreateWeaponDrop

const bool DEBUG_ONLY_COMMANDS = true // otherwise we'll enable all debugging things, maybe messy

array<string> nessieDebugger = ["1007270968017"]
table< string, int > playerAttackCountTable

const asset DEBUGGING_PARTICLE = $"P_plasma_exp_LG" // to control

const asset SCREENFX_WARPJUMP                      = $"P_warpjump_FP"
const asset SCREENFX_WARPJUMPDLIGHT                = $"warpjump_CH_dlight"
const asset FX_KILLSHOT_BLOODSPRAY                 = $"P_deathfx_human"
const asset FX_BLOODSPRAY_DECAL_SML                = $"P_deathfx_human_decal_SML"
const asset FX_BLOODSPRAY_DECAL_MED                = $"P_deathfx_human_decal_MED"
const asset FX_BLOODSPRAY_DECAL_LRG                = $"P_deathfx_human_decal_LRG"

struct
{
	int dropshipSpawnIndex = 0
} file

void function NessieDebug_Init()
{
	//AddClientCommandCallback( "mirage_decoy", CC_SpawnMirageDecoy )
	//AddClientCommandCallback( "spawnweapon", CC_SpawnWeapon )
	
	//AddClientCommandCallback( "freeaircontrol", CC_FreeAirControl )
	//AddClientCommandCallback( "nextDropshipSpawn", CC_GoNextDropshipSpawn )
	//AddClientCommandCallback( "pinkMistFxOnWorld", CC_PinkMistEffectOnWorld )
	//AddClientCommandCallback( "pinkMistFxOnSelf", CC_PinkMistEffectOnPlayer )

	if ( !DEBUG_ONLY_COMMANDS )
	{
		// new test things
		// these has been turn to unused
		//MeleeSyncedHuman_EnableRandomExecutions( true ) 
		//MeleeSyncedHuman_AlwaysDoAiExecutions( true )
		//MeleeSyncedTitan_EnableRandomExecutions( true )
		//MeleeSyncedTitan_AlwaysDoAiExecutions( true )
		//MeleeSyncedNPC_NPCUseNormalSyncedMelee( true )

		PrecacheParticleSystem( $"env_thaw_interior_tank_pollen" )
		PrecacheParticleSystem( $"P_ar_holopulse_CP" )
		PrecacheParticleSystem( $"overhead_icon_ai_friendly" )
		PrecacheParticleSystem( $"TDP_wave" )
		PrecacheParticleSystem( $"P_holo_screespace" )

		// blood
		PrecacheParticleSystem( $"death_pinkmist_LG" )
		PrecacheParticleSystem( $"death_pinkmist_LG_nochunk" ) // ideal for knock players down

		PrecacheParticleSystem( $"P_ar_impact_pilot" )
		PrecacheParticleSystem( $"P_ar_impact_pilot_headshot" )
		PrecacheParticleSystem( $"P_ar_impact_pilot_kill" )
		PrecacheParticleSystem( $"xo_spark_bolt" )

		PrecacheParticleSystem( $"xo_damage_exp_1" )
		PrecacheParticleSystem( $"xo_damage_exp_2" ) // ideal for knock players down
		PrecacheParticleSystem( $"xo_exp_death" )

		PrecacheParticleSystem( $"impact_flesh" )
		PrecacheParticleSystem( $"P_impact_metal_spectre" )

		// blood fog?
		PrecacheParticleSystem( $"P_impact_flesh_attacker" )
		PrecacheParticleSystem( $"P_impact_flesh_victim" )

		// lstar elec
		PrecacheParticleSystem( $"P_impact_lstar_victim" )
		
		// hitting decoy
		PrecacheParticleSystem( $"P_holohit_impact" )

		// doubletake flash
		PrecacheParticleSystem( $"P_impact_flesh_victim_elec" )

		// emp airblast
		PrecacheParticleSystem( $"P_impact_exp_emp_med_air" )

		// plasma impact
		PrecacheParticleSystem( $"P_plasma_exp_LG" )
		//

		PrecacheParticleSystem( SCREENFX_WARPJUMP )
		PrecacheParticleSystem( SCREENFX_WARPJUMPDLIGHT )
		PrecacheParticleSystem( FX_KILLSHOT_BLOODSPRAY )
		PrecacheParticleSystem( FX_BLOODSPRAY_DECAL_SML )
		PrecacheParticleSystem( FX_BLOODSPRAY_DECAL_MED )
		PrecacheParticleSystem( FX_BLOODSPRAY_DECAL_LRG )

		//Riff_ForceTitanAvailability( eTitanAvailability.Never )
		//Riff_ForceBoostAvailability( eBoostAvailability.Disabled )
		//AddCallback_OnPlayerRespawned( OnPlayerRespawned )
		//AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerGetsNewPilotLoadout )

		AddCallback_OnClientConnected( OnClientConnected )
		//HoldingUp_Props_Init()
	}
}


///////////////////////////
///// CLIENT COMMANDS /////
///////////////////////////

bool function SpawnHumanGib( entity player, array<string> args )
{
	CreateHumanGib( GetPlayerCrosshairOrigin( player ), player.EyeAngles() )
	return true
}

bool function CC_SpawnPilotMri( entity player, array<string> args )
{
	entity mri = CreatePeteMri( GetPlayerCrosshairOrigin( player ), player.EyeAngles() )
	SetTeam( mri, player.GetTeam() )
	return true
}

bool function CC_SpawnMirageDecoy( entity player, array<string> args )
{
	CreateMirageDecoyForPlayer( player )
	return true
}


bool function CC_SpawnWeapon( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player )

	CreateWeaponDrop( origin, < 0, 0, 0 >, "mp_weapon_smart_pistol" )
	return true
}

bool function CC_CreateRocketTurret( entity player, array<string> args )
{
	int team = player.GetTeam()
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >

	CreateRocketTurret( team, origin, angles )
	return true
}

bool function CC_CreateRocketRemoteTurret( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, player.EyeAngles().y, 0 >
	
	vector panelAngles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >
	vector panelOrigin = origin + AnglesToForward( panelAngles ) * 100 - < 0, 0, 10 > // 100 units closer to player

	CreateRemoteTurret( origin, angles, panelOrigin, panelAngles, ROCKET_TURRET_MODEL, "mp_turretweapon_blaster" )
	return true
}

bool function CC_CreatePlasmaRemoteTurret( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, player.EyeAngles().y, 0 >
	
	vector panelAngles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >
	vector panelOrigin = origin + AnglesToForward( panelAngles ) * 100 - < 0, 0, 10 > // 100 units closer to player

	CreateRemoteTurret( origin, angles, panelOrigin, panelAngles, PLASMA_TURRET_MODEL, "mp_turretweapon_plasma" )
	return true
}

bool function CC_CreateSentryRemoteTurret( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, player.EyeAngles().y, 0 >
	
	vector panelAngles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 > 
	vector panelOrigin = origin + AnglesToForward( panelAngles ) * 100 - < 0, 0, 10 > // 100 units closer to player

	CreateRemoteTurret( origin, angles, panelOrigin, panelAngles, HITSCAN_TURRET_MODEL, "mp_turretweapon_sentry" )
	return true
}

bool function CC_FreeAirControl( entity player, array<string> args )
{
	thread GiveFreeAirControlLifeLong( player )
	return true
}

void function GiveFreeAirControlLifeLong( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	array<string> classMods = player.GetPlayerSettingsMods()
	classMods.append( "disable_doublejump" )
	player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), classMods )

	while ( true )
	{
		player.SetGroundFrictionScale( 0.0 )
		player.kv.gravity = 0.0001

		vector angles = player.EyeAngles()
		angles.z = 0
		angles.x = 0
		angles.y = ClampAngle( angles.y - 90 )
		vector moveVel = GetVectorFromInput( player ) * 40 //AnglesToForward( angles ) * 40
		if ( player.IsInputCommandHeld( IN_JUMP ) )
		{
			moveVel.z = 40
			if ( player.IsOnGround() )
				moveVel.z = 230 // at least 230 vertical force required to lift a standing player
		}
		if ( player.IsInputCommandHeld( IN_DUCK ) || player.IsInputCommandHeld( IN_DUCKTOGGLE ) )
			moveVel.z = -40
		player.SetVelocity( player.GetVelocity() + moveVel )
		WaitFrame()
	}
}

vector function GetVectorFromInput( entity player )
{
	vector angles = player.EyeAngles()
	float xAxis = player.GetInputAxisRight()
	float yAxis = player.GetInputAxisForward()
	vector directionForward = GetDirectionFromInput( angles, xAxis, yAxis )

	return directionForward
}

vector function GetDirectionFromInput( vector playerAngles, float xAxis, float yAxis )
{
	playerAngles.x = 0
	playerAngles.z = 0
	vector forward = AnglesToForward( playerAngles )
	vector right = AnglesToRight( playerAngles )

	vector directionVec = Vector(0,0,0)
	directionVec += right * xAxis
	directionVec += forward * yAxis

	vector directionAngles = VectorToAngles( directionVec )
	vector directionForward = AnglesToForward( directionAngles )

	return directionForward
}

bool function CC_GoNextDropshipSpawn( entity player, array<string> args )
{
	array<entity> validDropshipSpawns
	array<entity> dropshipSpawns = GetEntArrayByClass_Expensive( "info_spawnpoint_dropship_start" )
	foreach ( entity dropshipSpawn in dropshipSpawns )
	{
		if ( dropshipSpawn.HasKey( "gamemode_" + GetSpawnpointGamemodeOverride() ) )
		{
			if ( dropshipSpawn.kv[ "gamemode_" + GetSpawnpointGamemodeOverride() ] == "0" )
				continue
		}

		validDropshipSpawns.append( dropshipSpawn )
	}

	int totalSpawns = validDropshipSpawns.len()
	entity currentDropshipSpawn = validDropshipSpawns[ file.dropshipSpawnIndex ]
	player.SetOrigin( currentDropshipSpawn.GetOrigin() )
	player.SetAngles( currentDropshipSpawn.GetAngles() )
	print( "Current mode has " + string( totalSpawns ) + " dropship spawns in total" )
	print( "This dropship spawn is: " + currentDropshipSpawn.GetTargetName() )
	print( "This dropship spawn's team: " + string( currentDropshipSpawn.GetTeam() ) )
	print( "dropshipSpawnIndex: " + string( file.dropshipSpawnIndex ) )

	file.dropshipSpawnIndex += 1
	if ( file.dropshipSpawnIndex == validDropshipSpawns.len() )
		file.dropshipSpawnIndex = 0

	return true
}

///////////////////////////////
///// CLIENT COMMANDS END /////
///////////////////////////////



/////////////////
///// DEBUG /////
/////////////////

// not work. oneHanded animation is done in .mdl not just code
void function TTF1_WeaponUsage( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	
	while( true )
	{
		WaitFrame()
		if( player.IsWallHanging() )
			continue
		if( player.IsWallRunning() )
			player.SetOneHandedWeaponUsageOff()
	}
}

void function SpawnHoloPulseAtPosition( vector origin, float radius, float lifeTime, float pulseSpeed )
{
	entity fxHandle = PlayFX( $"P_ar_holopulse_CP", origin, <0,0,0> )
	vector controlPoint = <lifeTime, pulseSpeed, 0.0> // controlPoint1: lifetime, controlPoint2: speed
	EffectSetControlPointVector( fxHandle, 1, controlPoint )
}

entity function CreatePeteMri( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )
	bodyGroupIndex = prop.FindBodyGroup( "mri" )
	prop.SetBodygroup( bodyGroupIndex, 1 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	thread RGB_Hightlight( prop )

	return prop
}

entity function CreateWeaponDrop( vector origin, vector angles, string weaponName, array<string> mods = [] )
{
	entity weapon = CreateWeaponEntityByNameWithPhysics( weaponName, origin, angles )
	weapon.SetMods( mods )

	weapon.SetUsable()
	weapon.SetUsableByGroup( "pilot" )
	weapon.kv.solid = SOLID_VPHYSICS
	//weapon.SetUsePrompts( "按住 %use% 以獲取武器", "按下 %use% 獲取武器" )

	return weapon
}

// TESTING! decoy in ttf2 is hardcoded and almost unchangable, guess apex make decoys move depend on their velocity( like, you can punch decoy and make them walk again )
void function CreateMirageDecoyForPlayer( entity player )
{
	entity decoy = player.CreatePlayerDecoy( 1.0 )
	//decoy.SetCloakDuration( 0, 0, 0 )
	decoy.SetMaxHealth( 50 )
	decoy.SetHealth( 50 )
	decoy.EnableAttackableByAI( 50, 0, AI_AP_FLAG_NONE )
	SetObjectCanBeMeleed( decoy, true )
	decoy.SetTimeout( 9999 )
	SetupDecoy_Common( player, decoy )
	DispatchSpawn( decoy )

	thread MirageDecoyThink( player, decoy )
}

void function MirageDecoyThink( entity player, entity decoy )
{
	player.EndSignal( "OnDestroy" )
	decoy.EndSignal( "OnDestroy" )

	entity decoyMover = CreateExpensiveScriptMover( player.GetOrigin(), player.GetAngles() )
	//decoy.SetParent( decoyMover, "REF" )

	//const float blendTime = 0.2
	//mover.MoveTo( end, 0.1, blendTime, 0 )
	//mover.RotateTo( angles, 0.2 )

	vector lastFramePos
	vector lastFrameAng

	while ( true )
	{
		//print( decoy.GetParent() )
		//print( decoyMover.GetOrigin() )
		//decoy.SetVelocity( < 0, 0, 0 > )
		decoy.SetOrigin( decoyMover.GetOrigin() )
		//decoy.SequenceTransitionFromEntity( player )
		//decoy.SetPoseParametersSameAs( player )
		//decoy.SetVelocity( player.GetVelocity() )
		WaitFrame()
	}
}



/////////////////////
///// CALLBACKS /////
/////////////////////

void function OnPlayerRespawned( entity player )
{
	thread PlayerAttackCounter( player )
}

void function PlayerAttackCounter( entity player )
{
	string uid = player.GetUID()
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	OnThreadEnd(
		function(): ( uid )
		{
			print( playerAttackCountTable[ uid ] )
		}
	)

	while( true )
	{
		player.WaitSignal( "OnPrimaryAttack" )
		playerAttackCountTable[ uid ] += 1
	}
}

void function OnPlayerGetsNewPilotLoadout( entity player, PilotLoadoutDef p )
{
	foreach( entity weapon in player.GetMainWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )
	player.TakeWeaponNow( player.GetOffhandWeapon( OFFHAND_SPECIAL ).GetWeaponClassName() )
	player.TakeWeaponNow( player.GetOffhandWeapon( OFFHAND_ORDNANCE ).GetWeaponClassName() )
	player.GiveWeapon( "mp_weapon_softball", ["northstar_softball", "grenadier_low_damage"] ) //["northstar_softball", "extended_ammo", "pas_fast_reload", "reload_repeat"]
	player.GiveWeapon( "mp_weapon_semipistol", ["gibber_pistol", "silencer", "pas_fast_reload", "extended_ammo"] )
	player.GiveWeapon( "mp_weapon_rocket_launcher", ["guided_missile", "at_unlimited_ammo"] )
	player.GiveOffhandWeapon( "mp_weapon_grenade_gravity", OFFHAND_SPECIAL )
	player.GiveOffhandWeapon( "mp_weapon_grenade_electric_smoke", OFFHAND_ORDNANCE, ["creeping_bombardment"] )
}

entity function GetPlayerAntiTitanWeapon( entity player )
{
	entity tempweapon
	foreach( entity weapon in player.GetMainWeapons() )
	{
		if( weapon.GetWeaponClassName() == "mp_weapon_defender" ||
			weapon.GetWeaponClassName() == "mp_weapon_mgl" ||
			weapon.GetWeaponClassName() == "mp_weapon_rocket_launcher" ||
			weapon.GetWeaponClassName() == "mp_weapon_arc_launcher"
		)
			tempweapon = weapon
	}
	return tempweapon
}

void function OnClientConnected( entity player )
{
	//AddPlayerHeldButtonEventCallback( player, IN_USE, CallbackFuncCornerUs, 0.3 )
	//AddPlayerHeldButtonEventCallback( player, IN_USE_AND_RELOAD, CallbackFuncCornerUs, 0.7 )
	//AddButtonPressedPlayerInputCallback( player, IN_USE, ShowEntityStats )
	//AddButtonPressedPlayerInputCallback( player, IN_DUCK, ShowEntityStats )
	//AddButtonPressedPlayerInputCallback( player, IN_USE, TEMP_PlayAnimGestureFromScript )
	//AddButtonPressedPlayerInputCallback( player, IN_USE, DebugParticle )
	//playerAttackCountTable[ player.GetUID() ] <- 0
}

void function CallbackFuncCornerUs( entity player )
{
	EmitSoundOnEntity( player, "diag_sp_intro_WD104_24_01_mcor_grunt1" )
}

void function ShowEntityStats( entity player )
{
	TraceResults traceResult = TraceLine( player.EyePosition(), player.EyePosition() + player.GetViewVector() * 1000, player, (TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), TRACE_COLLISION_GROUP_NONE )
	if( !IsValid( traceResult.hitEnt ) )
	{
		Chat_ServerPrivateMessage( player, "hitEnd Invalid", false )
		return
	}
	Chat_ServerPrivateMessage( player, "hitEnt is " + traceResult.hitEnt.GetClassName(), false )
	asset modelName = traceResult.hitEnt.GetModelName()
	string tempString = string( modelName )
    string modelString = tempString.slice( 2, tempString.len() - 1 )
	if( modelName != $"" )
		Chat_ServerPrivateMessage( player, "hitEnt's modelname is " + modelString, false )
}

entity function CreateEnvBeam( entity owner, entity startEnt, entity endEnt )
{
	entity env_laser = CreateEntity( "env_laser" )
	env_laser.kv.LaserTarget = endEnt.GetTargetName()
	env_laser.kv.rendercolor = "150 100 15"
	env_laser.kv.rendercolorFriendly = "15 100 150"
	env_laser.kv.renderamt = 255
	env_laser.kv.width = 2
	env_laser.SetValueForTextureKey( $"sprites/laserbeam.spr" )
	env_laser.kv.TextureScroll = 35
	env_laser.kv.damage = "0"
	env_laser.kv.dissolvetype = -1//-1 to 2 - none, energy, heavy elec, light elec
	env_laser.kv.spawnflags = 1// 32 end sparks
	env_laser.SetOrigin( startEnt.GetOrigin() )
	env_laser.SetAngles( startEnt.GetAngles() )
	env_laser.SetParent( startEnt )
	env_laser.s.parents <- [startEnt, endEnt]

	SetTeam( env_laser, owner.GetTeam() )

	DispatchSpawn( env_laser )

	return env_laser
}

void function SpawnWeaponEntity_CountLifeTime( entity player, string weaponName )
{
	vector origin = GetPlayerCrosshairOrigin( player ) + < 0,0,10 >
	vector angles = Vector( 0, 0, 0 )
	entity weapon = CreateWeaponEntityByNameWithPhysics( weaponName, origin, angles )
	float startTime = Time()
	weapon.WaitSignal( "OnDestroy" )
	float toalTime = Time() - startTime
	print( "This weapon lasted: " + string( toalTime ) )
}

void function DebugParticle( entity player )
{
    vector origin = GetPlayerCrosshairOrigin( player )

    array<entity> fx = []
	array<entity> cp = []

    entity cpRadius = CreateEntity( "info_placement_helper" )
	SetTargetName( cpRadius, UniqueString( "cloakBeacon_cpRadius" ) )
	cpRadius.SetOrigin( Vector(500,0,0) )
	DispatchSpawn( cpRadius )
	cp.append( cpRadius )
	
	// friendly fx
	entity cpColorF = CreateEntity( "info_placement_helper" )
	SetTargetName( cpColorF, UniqueString( "cloakBeacon_cpColorF" ) )
	cpColorF.SetOrigin( ENEMY_COLOR_FX )
	DispatchSpawn( cpColorF )
	cp.append( cpColorF )

    /*
	entity fxIdF1 = PlayFXWithControlPoint( DEPLOYABLE_CLOAKFIELD_FX_ALL, tower.GetOrigin() + Vector(0,0,3), cpColorF )
	SetTeam( fxIdF1, tower.GetTeam() )
	fxIdF1.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
	fx.append( fxIdF1 )
	entity fxIdF2 = PlayFXWithControlPoint( DEPLOYABLE_CLOAKFIELD_FX_ALL2, tower.GetOrigin() + Vector(0,0,3), cpColorF )
	SetTeam( fxIdF2, tower.GetTeam() )
	fxIdF2.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
	fx.append( fxIdF2 )
    */

	int particleIndex = GetParticleSystemIndex( DEBUGGING_PARTICLE )
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )
	StartParticleEffectOnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
	entity fxIdF3 = CreateEntity( "info_particle_system" )
	fxIdF3.kv.start_active = 1
	fxIdF3.SetValueForEffectNameKey( DEBUGGING_PARTICLE )
	SetTeam( fxIdF3, player.GetTeam() )
	fxIdF3.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
	SetTargetName( fxIdF3, UniqueString() )
	//fxIdF3.kv.cpoint1 = cpColorF.GetTargetName()
	//fxIdF3.kv.cpoint5 = cpRadius.GetTargetName()
	fxIdF3.SetOrigin( origin + Vector(0,0,10) )
	fx.append( fxIdF3 )

    DispatchSpawn( fxIdF3 )
}

void function PlayAnimGestureFromScript( entity ent, string activity, float fadein, float fadeout, float blendTime )
{
	ent.Anim_PlayGesture( activity, fadein, fadeout, blendTime )
}

void function TEMP_PlayAnimGestureFromScript( entity ent )
{
	print( "Try to Anim_PlayGesture()" )
	ent.SetPredictionEnabled( false )
	ent.Anim_PlayGesture( "ACT_MP_MELEE_KNIFE_FIRST", 2.0, 0.0, -1.0 )
}

void function CreateViewEntityForPlayer( entity player )
{
	entity viewControl = CreateEntity( "point_viewcontrol" )
	viewControl.kv.spawnflags = 56 // infinite hold time, snap to goal angles, make player non-soli
	
	vector eyeAngle = player.EyeAngles()
	vector evePos = player.EyePosition()
	vector offset = AnglesToForward( < 0, eyeAngle.y, 0 > ) * -150 + < 0,0,50 >
	vector angles = < 0, eyeAngle.y, 0 >
	viewControl.SetParent( player, "ORIGIN" )
	//viewControl.SetOrigin( evePos + offset )
	viewControl.SetOrigin( < -150, 0, 100 > )
	//viewControl.SetAngles( angles )
	DispatchSpawn( viewControl )
	
	player.SetViewEntity( viewControl, true )
	entity fpProxy = player.GetFirstPersonProxy()
	if ( IsValid( fpProxy )  )
		fpProxy.HideFirstPersonProxy()

	OnThreadEnd(
		function() : ( player, viewControl )
		{
			if( IsValid( player ) )
			{
				entity fpProxy = player.GetFirstPersonProxy()
				if( IsValid( fpProxy ) )
	            	fpProxy.ShowFirstPersonProxy()
				player.ClearViewEntity()
				RemoveCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
			}
			if( IsValid( viewControl ) )
				viewControl.Destroy()
		}
	)

	//wait 1
	//player.Die() // die here
	player.WaitSignal( "OnRespawned" )
}

void function StartTitanShieldHealthRegen( entity titan )
{
    entity soul = null // 初值赋为空，如果传入的泰坦是玩家且通过下方的检查没能获得soul实体，不执行回盾
    if ( titan.IsPlayer() ) // 如果传入的是玩家
    {
        if ( !titan.IsTitan() ) // 但这个玩家并不是泰坦
        {
            titan = titan.GetPetTitan() // 尝试获取该玩家的自动泰坦
            if ( IsValid( titan ) ) // 如果自动泰坦可用
                soul = titan.GetTitanSoul() // 获取该自动泰坦的soul实体

        }
        else // 玩家已经是泰坦
            soul = titan.GetTitanSoul()
    }
    else if ( titan.IsNPC() && titan.IsTitan() ) // 若为npc泰坦
        soul = titan.GetTitanSoul()

    if ( IsValid( soul ) ) // 防崩溃，仅在soul不为null的时候尝试再次启用回盾
        thread TitanShieldRegenThink( soul )
}