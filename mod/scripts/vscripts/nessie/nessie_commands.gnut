global function Nessie_Useful_Commands_Init

global function NessieCommands_EnableSuicide
struct
{
	bool killCommandsEnabled
	table<entity, bool> playerGainSpecialLoadout
} file

// BATTERY_SPAWNERS array in nessy.gnut controls avaibility
void function Nessie_Useful_Commands_Init()
{
	AddClientCommandCallback( "kill", SelfKillCommand )
	AddClientCommandCallback( "explode", SelfExplodeCommand )

    AddClientCommandCallback( "suicide", OPSuicide )
	//AddClientCommandCallback( "ragdoll", BeARagdoll )
	//AddClientCommandCallback( "fakedeath", FakeYourDeath )
	//AddClientCommandCallback( "dropweapon", PlayerDropActiveWeapon )
	AddClientCommandCallback( "selfdamage", OPSelfDamage )
	AddClientCommandCallback( "selfgib", OPSelfGib )
	//AddClientCommandCallback( "doomedtitan", CC_SpawnDoomedTitan )
	//AddClientCommandCallback( "doomedpilottitan", CC_SpawnDoomedPilotTitan )
	AddClientCommandCallback( "special", CC_GiveSpecialLoadout )

	// callbacks
	AddCallback_OnClientConnected( OnClientConnected )
	AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerChangeLoadout )
}

void function NessieCommands_EnableSuicide( bool enable )
{
	file.killCommandsEnabled = enable
}

void function OnClientConnected( entity player )
{
	// special loadout
	file.playerGainSpecialLoadout[ player ] <- false
}

void function OnPlayerRespawned( entity player )
{
	if ( file.playerGainSpecialLoadout[ player ] )
		DisableBoostBar( player )
}

void function OnPlayerChangeLoadout( entity player, PilotLoadoutDef p )
{
	if ( file.playerGainSpecialLoadout[ player ] )
		GivePlayerSpecialLoadout( player )
}


bool function SelfKillCommand( entity player, array<string> args )
{
	if ( file.killCommandsEnabled || GetConVarBool( "sv_cheats" ) || GetConVarBool( "ns_allow_kill_commands" ) )
	{
		if ( GetGameState() < eGameState.Playing ) // suicide only allowed after game start!
			return true
		if ( player.IsTitan() ) // no suicide allowed for titans
			return true
		if ( IsAlive( player ) )
			player.Die( svGlobal.worldspawn, svGlobal.worldspawn, { damageSourceId = damagedef_suicide } )
		print( "[NESSIE] " + player.GetPlayerName() + " gibbed themselves!" )
	}
	return true
}

bool function SelfExplodeCommand( entity player, array<string> args )
{
	if ( file.killCommandsEnabled || GetConVarBool( "sv_cheats" ) || GetConVarBool( "ns_allow_kill_commands" ) )
	{
		if ( GetGameState() < eGameState.Playing ) // suicide only allowed after game start!
			return true
		if ( player.IsTitan() ) // no suicide allowed for titans
			return true
		if ( IsAlive( player ) )
			player.Die( svGlobal.worldspawn, svGlobal.worldspawn, { scriptType = DF_GIB, damageSourceId = damagedef_suicide } )
		print( "[NESSIE] " + player.GetPlayerName() + " gibbed themselves!" )
	}
	return true
}

bool function OPSuicide( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	if ( GetGameState() < eGameState.Playing ) // suicide only allowed after game start!
		return true

	if( IsAlive( player ) )
	{
		//player.Die( svGlobal.worldspawn, svGlobal.worldspawn, { damageSourceId = damagedef_suicide } )
		player.Die( svGlobal.worldspawn, svGlobal.worldspawn, { damageSourceId = eDamageSourceId.round_end } )
	}

	print( "[NESSIE] Admin " + player.GetPlayerName() + " killed themselves!" )
	
	return true
}

bool function BeARagdoll( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	if( !GamePlaying() )
		return false

	ClearNessy( player )
	player.SetInvulnerable()
	HolsterAndDisableWeapons( player )
	player.BecomeRagdoll( Vector(0,0,0), false )
	print( "[NESSIE] " + player.GetPlayerName() + " has become ragdoll!" )
	return true
}

bool function FakeYourDeath( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	ClearNessy( player )
	player.SetContinueAnimatingAfterRagdoll( true )
	player.BecomeRagdoll( Vector(0,0,0), false )
	print( "[NESSIE] " + player.GetPlayerName() + " has fake their death!" )
	return true
}

bool function PlayerDropActiveWeapon( entity player, array<string> args )
{
	if( !IsValid( player.GetActiveWeapon() ) )
		return false

	player.DropWeapon( player.GetActiveWeapon() )
	print( "[NESSIE] " + player.GetPlayerName() + " dropped weapon!" )
	return true
}

bool function OPSelfDamage( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
    if( IsAlive( player ) )
	{
		// don't add "damageSourceId = damagedef_suicide", it's a kind of force kill!
        player.TakeDamage( 10000, null, null, {} ) 
		print( "[NESSIE] Admin " + player.GetPlayerName() + " self damaged!" )
	}
    return true
}

bool function OPSelfGib( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	if( IsAlive( player ) )
	{
		// don't add "damageSourceId = damagedef_suicide", it's a kind of force kill! 
		// damageType = DF_GIB will cause player's death blur become red?
        player.TakeDamage( 10000, null, null, { scriptType = DF_GIB } ) 
		print( "[NESSIE] Admin " + player.GetPlayerName() + " self gibbed!" )
	}
	return true
}

bool function CC_SpawnDoomedTitan( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	vector pos = GetPlayerCrosshairOrigin( player )
	vector angs = player.EyeAngles()
	entity titan = CreateOgre( TEAM_BOTH, pos, angs )
	DispatchSpawn( titan )

	titan.TakeDamage( titan.GetMaxHealth() + 1, null, null, 0 ) 
	//DoomTitan( titan )
	print( "[NESSIE] " + player.GetPlayerName() + " spawned a doomed titan!" )
	return true
}

bool function CC_SpawnDoomedPilotTitan( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector angs = player.EyeAngles()
	entity titan = CreateOgre( TEAM_BOTH, pos, angs )
	DispatchSpawn( titan )

	titan.TakeDamage( titan.GetMaxHealth() + 1, null, null, 0 ) 
	//DoomTitan( titan )
	print( "[NESSIE] " + player.GetPlayerName() + " spawned a doomed npc pilot titan!" )

	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) )
		return true

	// mark as having a pilot valid
	titanSoul.soul.seatedNpcPilot.isValid				= true
	titanSoul.soul.seatedNpcPilot.team 					= TEAM_BOTH

	titanSoul.soul.seatedNpcPilot.modelAsset 			= $"models/humans/pilots/pilot_medium_geist_m.mdl"
	titanSoul.soul.seatedNpcPilot.title 				= "PILOT"

	titanSoul.soul.seatedNpcPilot.isInvulnerable		= false

	titanSoul.soul.seatedNpcPilot.health				= 250

	return true
}

// special loadout
bool function CC_GiveSpecialLoadout( entity player, array<string> args )
{
	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	array<entity> targets
	if ( args.len() > 0 )
		targets = GetSpecialLoadoutPlayers( args[0] )
	if ( targets.len() < 0 )
		return true

	foreach ( entity player in targets )
		file.playerGainSpecialLoadout[ player ] = !file.playerGainSpecialLoadout[ player ]

	return true
}

array<entity> function GetSpecialLoadoutPlayers( string targetType )
{
	array<entity> players
	switch ( targetType )
	{
		case "all":
			players = GetPlayerArray()
			break
		default:
			players = GetPlayersFromNamePiece( targetType )
			break
	}

	return players
}

array<entity> function GetPlayersFromNamePiece( string namePiece )
{
    array<entity> foundPlayers
    foreach ( entity player in GetPlayerArray() )
    {
        string name = player.GetPlayerName()
        if ( name.tolower().find( namePiece.tolower() ) != null )
            foundPlayers.append( player )
    }

    return foundPlayers
}

void function DisableBoostBar( entity player )
{
    thread DisableBoostBar_Threaded( player )
}

void function DisableBoostBar_Threaded( entity player )
{
    WaitFrame() // wait for player earn meter being set up
    if( IsValid( player ) )
        PlayerEarnMeter_SetMode( player, eEarnMeterMode.DISABLED )
}

void function GivePlayerSpecialLoadout( entity player )
{
	thread GivePlayerSpecialLoadout_Threaded( player )
}

void function GivePlayerSpecialLoadout_Threaded( entity player )
{
	WaitFrame() // wait for anyother things set up
	if ( !IsAlive( player ) )
		return
	if ( !file.playerGainSpecialLoadout[ player ] )
		return

	foreach ( entity weapon in player.GetOffhandWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )
	player.GiveOffhandWeapon( "mp_ability_grapple", OFFHAND_SPECIAL, ["zipline_gun"] )
	player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_INVENTORY, ["jump_pad", "infinite_jump_pad"] )
	player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_ORDNANCE, ["wraith_portal", "amped_tacticals"] )
	player.GiveOffhandWeapon( "mp_weapon_grenade_gravity", OFFHAND_ANTIRODEO, ["gravity_lift"] )
}
//