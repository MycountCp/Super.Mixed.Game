global function Nessie_Funny_Functions_Init

global function RGB_Hightlight
global function TitleFlash

global function RainbowPlayerSkin
global function RainbowWeaponSkin

global function RGY_BatterySkin
global function HoloFlash_Loop
global function HoloFlash

global function TTF1_WeaponUsage
global function PlayerPulseBladeModel_HideBodyAndLegs
global function CreatePulseBladeHead
global function CreateWoundedHead
global function BindPulseBladeHeadToPlayer
global function BindeWoundedHeadToPlayer
global function CreateHumanGib
global function BecomeApexLegend
global function CreateRainbowDomeShield

global function CreatePeteMri

global function CreateWeaponDrop

global function NukeIncomingEffectForPlayer

global function CreateRocketTurret

global function CreateRemoteTurret

struct
{
	int dropshipSpawnIndex = 0
} file

void function Nessie_Funny_Functions_Init()
{
	// precaching
	PrecacheModel( ROCKET_TURRET_MODEL )
	// signals
    RegisterSignal( "StartRGBHighlight" )
	RegisterSignal( "EndRGBHighlight" )
    RegisterSignal( "StartSBTitle" )
	RegisterSignal( "EndSBTitle" )
	RegisterSignal( "StartRainbowPlayer" )
	RegisterSignal( "EndRainbowPlayer" )
	RegisterSignal( "StartRainbowWeapon" )
	RegisterSignal( "EndRainbowWeapon" )
	RegisterSignal( "StartRGYBattery" )
	RegisterSignal( "EndRGYBattery" )
	RegisterSignal( "StartHoloFlash" )
	RegisterSignal( "EndHoloFlash" )
	RegisterSignal( "NukeIncomingEffect" )

	//AddClientCommandCallback( "rainbowdome", CC_SpawnRainbowDome )
	//AddClientCommandCallback( "nessyoutfit", CC_SpawnNessyOutfit )
	AddClientCommandCallback( "rgbself", SelfRGBHighlight )
	//AddClientCommandCallback( "sbself", SelfIMSBTitle )
	//AddClientCommandCallback( "spawngib", SpawnHumanGib )
	//AddClientCommandCallback( "spawnmri", CC_SpawnPilotMri )
	//AddClientCommandCallback( "mirage_decoy", CC_SpawnMirageDecoy )
	//AddClientCommandCallback( "special", CC_GiveSpecialLoadout )
	//AddClientCommandCallback( "spawnweapon", CC_SpawnWeapon )
	//AddClientCommandCallback( "rocketturret", CC_CreateRocketTurret )
	//AddClientCommandCallback( "remoterocket", CC_CreateRocketRemoteTurret )
	//AddClientCommandCallback( "remoteplasma", CC_CreatePlasmaRemoteTurret )
	//AddClientCommandCallback( "remotesentry", CC_CreateSentryRemoteTurret )
	//AddClientCommandCallback( "freeaircontrol", CC_FreeAirControl )
	//AddClientCommandCallback( "nextDropshipSpawn", CC_GoNextDropshipSpawn )
}

// client commands
bool function CC_SpawnRainbowDome( entity player, array<string> args )
{
	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	CreateRainbowDomeShield( player.GetOrigin(), < 0,0,0 >, -1 )
	return true
}

bool function CC_SpawnNessyOutfit( entity player, array<string> args )
{
	SpawnNessyOutfit( player )
	return true
}

bool function SelfRGBHighlight( entity player, array<string> args )
{
	//if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
	//	return false

	thread RGB_Hightlight( player, true )
	return true
}

bool function SelfIMSBTitle( entity player, array<string> args )
{
	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	thread TitleFlash( player )
	return true
}

bool function SpawnHumanGib( entity player, array<string> args )
{
	CreateHumanGib( GetPlayerCrosshairOrigin( player ), player.EyeAngles() )
	return true
}

bool function CC_SpawnPilotMri( entity player, array<string> args )
{
	entity mri = CreatePeteMri( GetPlayerCrosshairOrigin( player ), player.EyeAngles() )
	SetTeam( mri, player.GetTeam() )
	return true
}

bool function CC_SpawnMirageDecoy( entity player, array<string> args )
{
	CreateMirageDecoyForPlayer( player )
	return true
}

bool function CC_GiveSpecialLoadout( entity player, array<string> args )
{
	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

		
	return true
}

bool function CC_SpawnWeapon( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player )

	CreateWeaponDrop( origin, < 0, 0, 0 >, "mp_weapon_smart_pistol" )
	return true
}

bool function CC_CreateRocketTurret( entity player, array<string> args )
{
	int team = player.GetTeam()
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >

	CreateRocketTurret( team, origin, angles )
	return true
}

bool function CC_CreateRocketRemoteTurret( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, player.EyeAngles().y, 0 >
	
	vector panelAngles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >
	vector panelOrigin = origin + AnglesToForward( panelAngles ) * 100 - < 0, 0, 10 > // 100 units closer to player

	CreateRemoteTurret( origin, angles, panelOrigin, panelAngles, ROCKET_TURRET_MODEL, "mp_turretweapon_blaster" )
	return true
}

bool function CC_CreatePlasmaRemoteTurret( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, player.EyeAngles().y, 0 >
	
	vector panelAngles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >
	vector panelOrigin = origin + AnglesToForward( panelAngles ) * 100 - < 0, 0, 10 > // 100 units closer to player

	CreateRemoteTurret( origin, angles, panelOrigin, panelAngles, PLASMA_TURRET_MODEL, "mp_turretweapon_plasma" )
	return true
}

bool function CC_CreateSentryRemoteTurret( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, player.EyeAngles().y, 0 >
	
	vector panelAngles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 > 
	vector panelOrigin = origin + AnglesToForward( panelAngles ) * 100 - < 0, 0, 10 > // 100 units closer to player

	CreateRemoteTurret( origin, angles, panelOrigin, panelAngles, HITSCAN_TURRET_MODEL, "mp_turretweapon_sentry" )
	return true
}

bool function CC_FreeAirControl( entity player, array<string> args )
{
	thread GiveFreeAirControlLifeLong( player )
	return true
}

void function GiveFreeAirControlLifeLong( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	array<string> classMods = player.GetPlayerSettingsMods()
	classMods.append( "disable_doublejump" )
	player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), classMods )

	while ( true )
	{
		player.SetGroundFrictionScale( 0.0 )
		player.kv.gravity = 0.0001

		vector angles = player.EyeAngles()
		angles.z = 0
		angles.x = 0
		angles.y = ClampAngle( angles.y - 90 )
		vector moveVel = GetVectorFromInput( player ) * 40 //AnglesToForward( angles ) * 40
		if ( player.IsInputCommandHeld( IN_JUMP ) )
		{
			moveVel.z = 40
			if ( player.IsOnGround() )
				moveVel.z = 230 // at least 230 vertical force required to lift a standing player
		}
		if ( player.IsInputCommandHeld( IN_DUCK ) || player.IsInputCommandHeld( IN_DUCKTOGGLE ) )
			moveVel.z = -40
		player.SetVelocity( player.GetVelocity() + moveVel )
		WaitFrame()
	}
}

vector function GetVectorFromInput( entity player )
{
	vector angles = player.EyeAngles()
	float xAxis = player.GetInputAxisRight()
	float yAxis = player.GetInputAxisForward()
	vector directionForward = GetDirectionFromInput( angles, xAxis, yAxis )

	return directionForward
}

vector function GetDirectionFromInput( vector playerAngles, float xAxis, float yAxis )
{
	playerAngles.x = 0
	playerAngles.z = 0
	vector forward = AnglesToForward( playerAngles )
	vector right = AnglesToRight( playerAngles )

	vector directionVec = Vector(0,0,0)
	directionVec += right * xAxis
	directionVec += forward * yAxis

	vector directionAngles = VectorToAngles( directionVec )
	vector directionForward = AnglesToForward( directionAngles )

	return directionForward
}

bool function CC_GoNextDropshipSpawn( entity player, array<string> args )
{
	array<entity> validDropshipSpawns
	array<entity> dropshipSpawns = GetEntArrayByClass_Expensive( "info_spawnpoint_dropship_start" )
	foreach ( entity dropshipSpawn in dropshipSpawns )
	{
		if ( dropshipSpawn.HasKey( "gamemode_" + GetSpawnpointGamemodeOverride() ) )
		{
			if ( dropshipSpawn.kv[ "gamemode_" + GetSpawnpointGamemodeOverride() ] == "0" )
				continue
		}

		validDropshipSpawns.append( dropshipSpawn )
	}

	int totalSpawns = validDropshipSpawns.len()
	entity currentDropshipSpawn = validDropshipSpawns[ file.dropshipSpawnIndex ]
	player.SetOrigin( currentDropshipSpawn.GetOrigin() )
	player.SetAngles( currentDropshipSpawn.GetAngles() )
	print( "Current mode has " + string( totalSpawns ) + " dropship spawns in total" )
	print( "This dropship spawn is: " + currentDropshipSpawn.GetTargetName() )
	print( "This dropship spawn's team: " + string( currentDropshipSpawn.GetTeam() ) )
	print( "dropshipSpawnIndex: " + string( file.dropshipSpawnIndex ) )

	file.dropshipSpawnIndex += 1
	if ( file.dropshipSpawnIndex == validDropshipSpawns.len() )
		file.dropshipSpawnIndex = 0

	return true
}
//

void function RGB_Hightlight( entity ent, bool showToAll = false, bool alwaysShow = false )
{
	OnThreadEnd(
		function(): ( ent )
		{
			if( IsValid( ent ) )
			{
				Highlight_ClearFriendlyHighlight( ent )
				Highlight_ClearEnemyHighlight( ent )
				Highlight_ClearNeutralHighlight( ent )
			}
		}
	)
	ent.Signal( "StartRGBHighlight" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartRGBHighlight" )
	ent.EndSignal( "EndRGBHighlight" )
	
	string highlightToUse = "sp_enemy_pilot" // normal one
	if ( alwaysShow )
		highlightToUse = "sp_friendly_hero" // this one will show across walls

	Highlight_SetFriendlyHighlight( ent, highlightToUse )
	if( showToAll )
	{
		Highlight_SetEnemyHighlight( ent, highlightToUse )
		Highlight_SetNeutralHighlight( ent, highlightToUse )
	}
	array<vector> colorArray = [ < 255,0,0 >, < 0,255,0 >, < 0,0,255 > ]
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == colorArray.len() - 1 ? 0 : index + 1

		ent.Highlight_SetParam( 1, 0, colorArray[index] ) // friendly
		if( showToAll )
		{
			ent.Highlight_SetParam( 2, 0, colorArray[index] ) // enemy
			ent.Highlight_SetParam( 0, 0, colorArray[index] ) // neutral
		}
	}
}

void function TitleFlash( entity ent, array<string> titleArray = [ "我是傻逼", "傻逼是我" ] )
{
	if ( titleArray.len() <= 0 ) // no title given
		return
	ent.Signal( "StartSBTitle" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartSBTitle" )
	ent.EndSignal( "EndSBTitle" )

	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == titleArray.len() - 1 ? 0 : index + 1

		ent.SetTitle( titleArray[index] )
	}
}

void function RainbowPlayerSkin( entity player )
{
	if( !IsVanillaPilotModel( player ) )
		return
	player.Signal( "StartRainbowPlayer" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartRainbowPlayer" )
	player.EndSignal( "EndRainbowPlayer" )

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		player.SetSkin( 1 )
		player.SetCamo( camoIndexArray[index] )
	}
}

bool function IsVanillaPilotModel( entity player )
{
	asset modelName = player.GetModelName()
	if( modelName == $"models/humans/pilots/pilot_medium_stalker_m.mdl" ||
		modelName == $"models/humans/pilots/pilot_medium_stalker_f.mdl" ||
		modelName == $"models/humans/pilots/pilot_light_ged_m.mdl" ||
		modelName == $"models/humans/pilots/pilot_light_ged_f.mdl" ||
		modelName == $"models/humans/pilots/pilot_light_jester_m.mdl" ||
		modelName == $"models/humans/pilots/pilot_light_jester_f.mdl" ||
		modelName == $"models/humans/pilots/pilot_medium_reaper_m.mdl" ||
		modelName == $"models/humans/pilots/pilot_medium_reaper_f.mdl" ||
		modelName == $"models/humans/pilots/pilot_medium_geist_m.mdl" ||
		modelName == $"models/humans/pilots/pilot_medium_geist_f.mdl" ||
		modelName == $"models/humans/pilots/pilot_heavy_roog_m.mdl" ||
		modelName == $"models/humans/pilots/pilot_heavy_roog_f.mdl" ||
		modelName == $"models/humans/pilots/pilot_heavy_drex_m.mdl" ||
		modelName == $"models/humans/pilots/pilot_heavy_drex_f.mdl"
	 )
	 	return true

	return false
}

void function RainbowWeaponSkin( entity weaponOwner )
{
	weaponOwner.Signal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "OnDestroy" )
	weaponOwner.EndSignal( "OnDeath" )
	weaponOwner.EndSignal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "EndRainbowWeapon" )

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		foreach( entity weapon in weaponOwner.GetMainWeapons() )
		{
			weapon.SetSkin( 1 )
			weapon.SetCamo( camoIndexArray[index] )
		}
	}
}

void function RGY_BatterySkin( entity battery )
{
	if( battery.GetClassName() != "item_titan_battery" )
		return

	battery.Signal( "StartRGYBattery" )
	battery.EndSignal( "OnDestroy" )
	battery.EndSignal( "StartRGYBattery" )
	battery.EndSignal( "EndRGYBattery" )

	int index = 0
	while( true )
	{
		//print( "setting battery skin: " + string( index ) )
		WaitFrame()
		battery.SetSkin( index )
		Battery_StopFX( battery )
		if( index == 2 )
			index = 0
		else
			index++
	}
}

void function HoloFlash_Loop( entity player, float interval = 1.0 )
{
	player.Signal( "StartHoloFlash" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartHoloFlash" )
	player.EndSignal( "EndHoloFlash" )

	while( true )
	{
		wait interval

		HoloFlash( player )
	}
}

void function HoloFlash( entity player )
{
	int attachIndex = player.LookupAttachment( "CHESTFOCUS" )
	//StartParticleEffectOnEntity( player, GetParticleSystemIndex( GHOST_TRAIL_EFFECT ), FX_PATTACH_POINT_FOLLOW, attachIndex )
	entity flashFX = StartParticleEffectOnEntity_ReturnEntity( player, GetParticleSystemIndex( GHOST_FLASH_EFFECT ), FX_PATTACH_POINT, attachIndex )
	flashFX.SetOwner( player )
	SetTeam( flashFX, player.GetTeam() )
	flashFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // not owner only
}

// not work. oneHanded animation is done in .mdl not just code
void function TTF1_WeaponUsage( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	
	while( true )
	{
		WaitFrame()
		if( player.IsWallHanging() )
			continue
		if( player.IsWallRunning() )
			player.SetOneHandedWeaponUsageOff()
	}
}

void function PlayerPulseBladeModel_HideBodyAndLegs( entity player )
{
	player.SetModel( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = player.FindBodyGroup( "body" )
	player.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = player.FindBodyGroup( "legs" )
	player.SetBodygroup( bodyGroupIndex, 0 )
}

// create a pulseblade pilot's head
entity function CreatePulseBladeHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

// create a headshot head! this is not a model that can freely scale
entity function CreateWoundedHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )
	bodyGroupIndex = prop.FindBodyGroup( "head" )
	prop.SetBodygroup( bodyGroupIndex, 1 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

void function BindPulseBladeHeadToPlayer( entity player )
{
	entity head = CreatePulseBladeHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
	
	//head.SetSkin( 2 )
	//head.SetCamo( 14 )
}

void function BindeWoundedHeadToPlayer( entity player )
{
	entity head = CreateWoundedHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
}

void function TrackPlayerDeathForHeadProp( entity player, entity head )
{
	player.EndSignal( "OnDestroy" )

	WaitFrame() // since altpilot resets player's visibility everytime they respawn or changeloadout
	player.kv.VisibilityFlags = 0 // hide player

	OnThreadEnd(
		function():( head )
		{
			if ( IsValid( head ) )
				head.Destroy()
		}
	)

	player.WaitSignal( "OnDeath" )
	player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE // restore player visibility!
}

/* 
	index
	studio "gib_lump_LOD0.smd"
	studio "gib_small_02_LOD0.smd"
	studio "gib_brain_LOD0.smd"
	studio "gib_muscle_LOD0.smd"
	studio "gib_small_01_LOD0.smd"
*/
entity function CreateHumanGib( vector origin, vector angles, float scale = 1.0, int styleIndex = -1 )
{
	entity prop_physics = CreateEntity( "prop_physics" )
	prop_physics.SetValueForModelKey( $"models/gibs/human_gibs.mdl" )
	prop_physics.SetModel( $"models/gibs/human_gibs.mdl" ) // required to make finding bodygroup work
	prop_physics.kv.spawnflags = 4 // 4 = SF_PHYSPROP_DEBRIS
	prop_physics.kv.fadedist = 2000
	prop_physics.kv.renderamt = 255
	prop_physics.kv.rendercolor = "255 255 255"
	prop_physics.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS

	// funny things
	int bodyGroupIndex = prop_physics.FindBodyGroup( "gibs" )
	int maxBodyGroup = prop_physics.GetBodyGroupModelCount( bodyGroupIndex )
	int bodygroupValue
	if ( styleIndex == -1 ) // not setting...
		bodygroupValue = RandomInt( maxBodyGroup ) // get a random one
	else
		bodygroupValue = styleIndex
	prop_physics.SetBodygroup( bodyGroupIndex, bodygroupValue )

	prop_physics.kv.modelscale = scale

	prop_physics.SetOrigin( origin )
	prop_physics.SetAngles( angles )
	DispatchSpawn( prop_physics )
	prop_physics.SetModel( $"models/gibs/human_gibs.mdl" )
	thread DelayedPinkmistGib( prop_physics )

	return prop_physics
}

void function DelayedPinkmistGib( entity gib )
{
	gib.EndSignal( "OnDestroy" )

	wait 1
	gib.Dissolve( ENTITY_DISSOLVE_PINKMIST, < 0, 0, 0 >, 0 )
}

void function BecomeApexLegend( entity player, string model = "ash" ) // ash, blisk, jack, sarah
{
	TakeAllWeapons( player )

	player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, ["wraith_phase"] )
	player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_ORDNANCE, ["octane_stim"] )
	player.GiveOffhandWeapon( "mp_weapon_hard_cover", OFFHAND_ANTIRODEO, ["deployable_dome_shield"] )
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, ["pushback_melee"] )
	player.GiveWeapon( "mp_weapon_gunship_missile", ["pilot_emptyhanded"] )
	player.SetActiveWeaponByName( "mp_weapon_gunship_missile" )
	player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), ["disable_doublejump","only_wallclimb", "pas_wallhang"] )

	asset modelToUse
	if ( model == "ash" )
		modelToUse = $"models/Humans/heroes/imc_hero_ash.mdl"
	else if ( model == "blisk" )
		modelToUse = $"models/Humans/heroes/imc_hero_blisk.mdl"
	else if ( model == "jack" )
		modelToUse = $"models/humans/heroes/mlt_hero_jack.mdl"
	else if ( model == "sarah" )
		modelToUse = $"models/Humans/heroes/mlt_hero_sarah.mdl"

	player.SetModel( modelToUse )
	GivePassive( player, ePassives.PAS_STEALTH_MOVEMENT ) // hide jetpack flame

	thread DisableBoostBar( player )
}

void function DisableBoostBar( entity player )
{
	WaitFrame()
	if( IsValid( player ) )
		PlayerEarnMeter_SetMode( player, eEarnMeterMode.DISABLED )
}

entity function CreateRainbowDomeShield( vector origin, vector angles, float duration = -1, bool notSolid = false )
{
	entity bubbleShield = CreateEntity( "prop_dynamic" )
	bubbleShield.SetValueForModelKey( $"models/fx/xo_shield.mdl" )
	if ( !notSolid )
		bubbleShield.kv.solid = SOLID_VPHYSICS
    bubbleShield.kv.rendercolor = "81 130 151"
    bubbleShield.kv.contents = (int(bubbleShield.kv.contents) | CONTENTS_NOGRAPPLE)
	bubbleShield.SetOrigin( origin )
	bubbleShield.SetAngles( angles )
	bubbleShield.Hide()

     // Blocks bullets, projectiles but not players and not AI
	bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS
	bubbleShield.SetBlocksRadiusDamage( true )
	DispatchSpawn( bubbleShield )
    array<entity> bubbleShieldFXs
	vector coloredFXOrigin = bubbleShield.GetOrigin()
	table bubbleShieldDotS = expect table( bubbleShield.s )

	//Create friendly and enemy colored particle systems
	entity rainbowColoredFX = StartParticleEffectInWorld_ReturnEntity( BUBBLE_SHIELD_FX_PARTICLE_SYSTEM_INDEX, coloredFXOrigin, angles )
	thread RainbowColorThink( rainbowColoredFX )
	bubbleShieldFXs.append( rainbowColoredFX )

    EmitSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
    thread CleanupBubbleShield( bubbleShield, bubbleShieldFXs, duration )

	return bubbleShield
}

void function RainbowColorThink( entity fx )
{
	fx.EndSignal( "OnDestroy" )

	vector rgb = < 255, 0, 0 > // start with red
	float segment = 25.5
	while ( true )
	{
		WaitFrame()

		// to < 255, 255, 0 >
		if ( rgb.x == 255 && rgb.y < 255 && rgb.z == 0 )
			rgb.y = min( 255, rgb.y + segment )
		// to < 0, 255, 0 >
		else if ( rgb.x > 0 && rgb.y == 255 && rgb.z == 0 )
			rgb.x = max( 0, rgb.x - segment )
		// to < 0, 255, 255 >
		else if ( rgb.x == 0 && rgb.y == 255 && rgb.z < 255 )
			rgb.z = min( 255, rgb.z + segment )
		// to < 0, 0, 255 >
		else if ( rgb.x == 0 && rgb.y > 0 && rgb.z == 255 )
			rgb.y = max( 0, rgb.y - segment )
		// to < 255, 0, 255 >
		else if ( rgb.x < 255 && rgb.y == 0 && rgb.z == 255 )
			rgb.x = min( 255, rgb.x + segment )
		// to < 255, 0, 0 >, a whole loop done
		else if ( rgb.x == 255 && rgb.y == 0 && rgb.z > 0 )
			rgb.z = max( 0, rgb.z - segment )

		//print( rgb )
		EffectSetControlPointVector( fx, 1, rgb )
	}
}

/* // can't handle < 0,0,0 > or < 255,255,255 >
void function RainbowColorThink( entity fx )
{
	fx.EndSignal( "OnDestroy" )

	vector rgb = < 0,0,255 > // start with blue
	int curCol = 1 // 1 = red, 2 = green, 3 = blue
	int loopCount = 0 // every 3 loop needs to reset one color, otherwise it becomes < 0,0,0 > or < 255,255,255 >
	float seg = 50.0
	bool reversed = false
	while ( true )
	{
		WaitFrame()
		if ( !reversed )
		{
			if ( curCol == 1 )
				rgb.x = min( 255, rgb.x + seg )
			else if ( curCol == 2 )
				rgb.y = min( 255, rgb.y + seg )
			else if ( curCol == 3 )
				rgb.z = min( 255, rgb.z + seg )
		}
		else
		{
			if ( curCol == 1 )
				rgb.x = max( 0, rgb.x - seg )
			else if ( curCol == 2 )
				rgb.y = max( 0, rgb.y - seg )
			else if ( curCol == 3 )
				rgb.z = max( 0, rgb.z - seg )
		}

		if ( !reversed )
		{
			if ( rgb.x >= 255 && curCol == 1 )
				curCol = 2
			else if ( rgb.y >= 255 && curCol == 2 )
				curCol = 3
			else if ( rgb.z >= 255 && curCol == 3 )
			{
				curCol = 1
				reversed = true
			}
		}
		else
		{
			if ( rgb.x <= 0 && curCol == 1 )
				curCol = 2
			else if ( rgb.y <= 0 && curCol == 2 )
				curCol = 3
			else if ( rgb.z <= 0 && curCol == 3 )
			{
				curCol = 1
				reversed = false
			}
		}

		print( rgb )
		EffectSetControlPointVector( fx, 1, rgb )
	}
}
*/

void function CleanupBubbleShield( entity bubbleShield, array<entity> bubbleShieldFXs, float fadeTime )
{
	bubbleShield.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function () : ( bubbleShield, bubbleShieldFXs )
		{
			if ( IsValid_ThisFrame( bubbleShield ) )
			{
				StopSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
				EmitSoundOnEntity( bubbleShield, "BubbleShield_End" )
				DestroyBubbleShield( bubbleShield )
			}

			foreach ( fx in bubbleShieldFXs )
			{
				if ( IsValid_ThisFrame( fx ) )
				{
					EffectStop( fx )
				}
			}
		}
	)

	if ( fadeTime == -1 ) // default
		WaitForever()
	else if ( fadeTime > 0 )
		wait fadeTime
}

entity function CreatePeteMri( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )
	bodyGroupIndex = prop.FindBodyGroup( "mri" )
	prop.SetBodygroup( bodyGroupIndex, 1 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	thread RGB_Hightlight( prop )

	return prop
}

entity function CreateWeaponDrop( vector origin, vector angles, string weaponName, array<string> mods = [] )
{
	entity weapon = CreateWeaponEntityByNameWithPhysics( weaponName, origin, angles )
	weapon.SetMods( mods )

	weapon.SetUsable()
	weapon.SetUsableByGroup( "pilot" )
	weapon.kv.solid = SOLID_VPHYSICS
	//weapon.SetUsePrompts( "按住 %use% 以獲取武器", "按下 %use% 獲取武器" )

	return weapon
}

// TESTING! decoy in ttf2 is hardcoded and almost unchangable, guess apex make decoys move depend on their velocity( like, you can punch decoy and make them walk again )
void function CreateMirageDecoyForPlayer( entity player )
{
	entity decoy = player.CreatePlayerDecoy( 1.0 )
	//decoy.SetCloakDuration( 0, 0, 0 )
	decoy.SetMaxHealth( 50 )
	decoy.SetHealth( 50 )
	decoy.EnableAttackableByAI( 50, 0, AI_AP_FLAG_NONE )
	SetObjectCanBeMeleed( decoy, true )
	decoy.SetTimeout( 9999 )
	SetupDecoy_Common( player, decoy )
	DispatchSpawn( decoy )

	thread MirageDecoyThink( player, decoy )
}

void function MirageDecoyThink( entity player, entity decoy )
{
	player.EndSignal( "OnDestroy" )
	decoy.EndSignal( "OnDestroy" )

	entity decoyMover = CreateExpensiveScriptMover( player.GetOrigin(), player.GetAngles() )
	//decoy.SetParent( decoyMover, "REF" )

	//const float blendTime = 0.2
	//mover.MoveTo( end, 0.1, blendTime, 0 )
	//mover.RotateTo( angles, 0.2 )

	vector lastFramePos
	vector lastFrameAng

	while ( true )
	{
		//print( decoy.GetParent() )
		//print( decoyMover.GetOrigin() )
		//decoy.SetVelocity( < 0, 0, 0 > )
		decoy.SetOrigin( decoyMover.GetOrigin() )
		//decoy.SequenceTransitionFromEntity( player )
		//decoy.SetPoseParametersSameAs( player )
		//decoy.SetVelocity( player.GetVelocity() )
		WaitFrame()
	}
}

// test nuke thing
void function NukeIncomingEffectForPlayer( entity player, float timeBeforeNuke = 2.5 )
{
	player.EndSignal( "OnDestroy" )
	player.Signal( "NukeIncomingEffect" )
	player.EndSignal( "NukeIncomingEffect" )
	float bloomScale = 1.0
	float sunScale = -1.0

	EmitSoundOnEntityOnlyToPlayer( player, player, "titan_nuclear_death_alarm" )
	wait 1.2
	
	float endTime = Time() + timeBeforeNuke + 0.6
	EmitSoundOnEntityOnlyToPlayer( player, player, "titan_nuclear_death_charge" )
	
	thread DelayedDoNukeSound( player, timeBeforeNuke )
	while ( Time() < endTime )
	{
		Remote_CallFunction_Replay( player, "ServerCallback_ScreenShake", 5, 10, 0.5 )
		Remote_CallFunction_NonReplay( player, "ServerCallback_SetMapSettings", bloomScale, false, 1.0, 1.0, 1.0, 0, 0, sunScale, 1.0 )
		bloomScale += 0.2
		sunScale -= 0.1
		WaitFrame()
	}
}

void function DelayedDoNukeSound( entity player, float timeBeforeNuke )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "NukeIncomingEffect" )
	wait timeBeforeNuke
	ScreenFade( player, 255, 255, 255, 255, 0.5, 10, FFADE_OUT | FFADE_PURGE )
	wait 0.9
	Remote_CallFunction_NonReplay( player, "ServerCallback_ResetMapSettings" )
	EmitSoundOnEntityOnlyToPlayer( player, player, "titan_nuclear_death_explode" )
	wait 10
}

// turrets
entity function CreateRocketTurret( int team, vector origin, vector angles )
{
	entity turret = CreateNPC( "npc_turret_sentry", team, origin, angles )
	turret.StartDeployed()
	SetSpawnOption_AISettings( turret, "npc_turret_sentry_plasma" )
	SetSpawnOption_Weapon( turret, "mp_turretweapon_blaster" )
	DispatchSpawn( turret )
	turret.SetTitle( "#WPN_BLASTER_TURRET" )
	turret.SetModel( ROCKET_TURRET_MODEL )
	//turret.TakeActiveWeapon()
	//turret.GiveWeapon( "mp_turretweapon_blaster" )
	//turret.SetActiveWeaponByName( "mp_turretweapon_blaster" )

	return turret
}

/* // turret settings
	"droppod_fireteam_turret"
	"PROTO_at_turret"		// have special pov
	"redeye_turret"
	"redeye_turret_ai"
	"sat_strike_turret"		// cannot change direction
	"turret_imc_lrg"
*/

/* // turret models
	SENTRY_TURRET_MODEL and PLASMA_TURRET_MODEL(same)
	ROCKET_TURRET_MODEL
	HITSCAN_TURRET_MODEL
*/

entity function CreateRemoteTurret( vector origin, vector angles, vector panelOrigin, vector panelAngles, asset turretModel, string turretWeapon )
{
	RemoteTurretSettings info

	info.turretOrigin = origin
	info.turretAngles = angles
	info.panelOrigin = panelOrigin
	info.panelAngles = panelAngles

	info.turretSettingsName		= "PROTO_at_turret"
	info.weaponName				= turretWeapon
	info.turretModel			= turretModel
	info.panelModel				= CONTROL_PANEL_MODEL

	info.viewClampEnabled		= true
	info.viewClampRangeYaw		= 120
	info.viewClampRangePitch	= 120
	info.viewStartPitch			= 0

	entity turret = CreateRemoteTurretAndControlPanel( info )
	return turret
}