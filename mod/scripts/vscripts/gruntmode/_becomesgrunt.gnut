untyped

global function BecomesGruntMode_Init

global function GruntMode_RegisterPlayerClass
global function GruntMode_IsSpecialistClass // for score events in gruntmode.gnut

const array<string> GRUNT_CHATTERS = 
[ 
	"diag_sp_intro_WD104_24_01_mcor_grunt1",
	"diag_sp_intro_WD103_02_01_mcor_grunt2",
	"diag_sp_intro_WD104_26_01_mcor_grunt3",
	"diag_sp_intro_WD104_25_01_mcor_grunt2",
	"diag_sp_intro_WD104_29_01_mcor_grunt6"
]
//"diag_sp_intro_WD103_02_01_mcor_grunt2" Backup! Backup!
//"diag_sp_intro_WD104_26_01_mcor_grunt3" We can't stay here, move, move!
//"diag_sp_ReaperTown_BM103_01a_01_mcor_grunt2" Look, a pilot! now they're doing our favor
//"diag_sp_intro_WD104_24_01_mcor_grunt1" They're trying to corner us!
//"diag_sp_intro_WD104_25_01_mcor_grunt2" We can't let them turn us down, we need to move!
//"diag_sp_intro_WD104_29_01_mcor_grunt6" Do we have any pilots in the area?

// npc damage settings!!!
const float NPC_PILOT_DAMAGE_MULTIPLIER = 2.5
const float NPC_PROWLER_DAMAGE_MULTIPLIER = 0.3
const float NPC_SUPER_SPECTRE_ROCKET_DAMAGE_MULTIPLIER = 0.6


struct PlayerClassStruct
{
	string className
	void functionref( entity player ) classLoadoutFunction
	bool isSpecialist // killing a specialist class will give more scores
}

struct
{
	table< string, bool > playerChatterTable // this is for making cooldowns between chatters, checking uids
	table< entity, string > playerClassTable // this is for saving player's class
	table< string, PlayerClassStruct > gruntModeClasses // this is for saving all valid classes
} file

void function BecomesGruntMode_Init()
{
	PrecacheModel( $"models/humans/grunts/imc_grunt_shield_captain.mdl" )

	SetLoadoutGracePeriodEnabled( false ) // no loadout switch allowed!
	PlayerEarnMeter_SetEnabled( false ) // disable earnmeter

	// hacked death
	// may mess up highlights( client won't clean up npc's DeathRecapHighlight )
	//HackedDeath_SetEnabled( true )
	//HackedDeath_SetFakeBodySilence( false ) // so grunts will have death sounds
	//HackedDeath_SetDeathEffectEnable( false ) // disable death effect

	// specifics!!!!
	// night combat simulation
	if ( CoinFlip() ) // has 50% chance to use night fight
		Night_Combat_Settings_Init()
	// score
	ScoreEvent_DisableCallSignEvent( true ) // since players are grunts, never show callsign things
	// health regen
	HealthRegen_SetCustomRegenDelay( 6.0, 6.0, 6.0 ) // grunt's health regen delay is forced to be 6.0(no matter pas_fast_health_regen is equiped)
	HealthRegen_SetCustomRegenRate( 4.0, 4.0 ) // grunt's health regen rate is forced to be 4.0
	// highlight
	//Highlight_HideDefaultEnemyHighlight( true ) // this will hide enemy's highlights
	Highlight_SetCustomHighlightFunction( GruntModeHighlight )
	// death effects
	SetDeathCamLengthForced( 0.5 ) // don't want to display a long death cam, player.SetPlayerSettings( "spectator" ) has been fixed
	//SetPlayerDeathFlashHidden( true ) // actually not hidden, just fade from black, but looks better
	//SetKillcamsEnabled( false ) // disable replay, no need since we've made a delayed replay system
	// npc executions
	//MeleeSyncedNPC_EnableAll_Init() // npc executions for fun
	MeleeSyncedNPC_AllowNPCTitanExecutions( true )
	MeleeSyncedNPC_AllowNPCPilotExecutions( true )
	MeleeSyncedNPC_AllowNPCGruntExecutions( true ) // spectres don't have neck snap attacker sequence
	Melee_SetPlayerClassicExecutionsEnabled( true ) // best execution for grunt players, real grunts still use cool executions
	MeleeSyncedNPC_AllowNPCPilotExecuteOtherNPCs( true ) // pilot models don't have syncedMeleeData, so let them use mp executions
	// rodeo
	Rodeo_BatteryThiefHighlightEnabled( false ) // you don't have to worry about the highlight
	/*
	ClassicRodeo_SetEnabled( true )
	ClassicRodeo_AllowContinouslyRemoveBattery( true ) // so you can rip battery all day long!
	ClassicRodeo_SetBatteryRemovalDamageAmped( true ) // rodeo will deal large damage to titans
	ClassicRodeo_SetAdditionalDamageScale( 1.0 ) // since ripping battery is always, we should also deal additional damage on rodeo to catch up with it
	ClassicRodeo_BatteryContainerOnlyProtectsOnce( false )
	ClassicRodeo_OwnerApplyBatteryAllowed( true )
	ClassicRodeo_SetShouldAutomaticallyDoRodeoSequence( false )
	*/

	// tempfix specifics!
	SetShouldPlayFactionDialogue( false ) // don't announce player!
	SetBattleChatterEnabled_Northstar( false ) // grunt mode are having some special chatters, disable default one
	SetWeaponDropsEnabled( false ) // another fixed thing only with tempfix

	AddCallback_OnClientConnected( OnClientConnected )
	AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerChangeLoadout )
	AddCallback_OnPlayerKilled( OnPlayerKilled )
	AddCallback_GameStateEnter( eGameState.Prematch, OnGamePrematch )

	// ai configs
	AddSpawnCallback( "npc_soldier", GruntConfig )
	AddSpawnCallback( "npc_pilot_elite", PilotConfig )
	AddSpawnCallback( "npc_marvin", MarvinConfig )
	AddSpawnCallback( "npc_prowler", ProwlerConfig )
	AddSpawnCallback( "npc_spectre", SpectreConfig )
	AddSpawnCallback( "npc_stalker", StalkerConfig )
	AddSpawnCallback( "npc_super_spectre", ReaperConfig )
	AddSpawnCallback( "npc_titan", TitanConfig )
	AddSpawnCallback( "npc_drone", DroneConfig )
	AddSpawnCallback( "npc_gunship", GunshipConfig )
	AddSpawnCallback( "npc_dropship", DropshipConfig )
	AddSpawnCallback( "npc_frag_drone", TickConfig )
	AddSpawnCallback( "npc_turret_sentry", TurretConfig )

	// ai damages
	AddDamageByCallback( "npc_pilot_elite", BuffPilotDamage )
	//MeleeSyncedNPC_AllowExecutingNPCPilot( true ) // hard to perform, but you can oneshot pilots with this
	AddDamageCallbackSourceID( eDamageSourceId.prowler_melee, NerfProwlerMelee )
	AddDamageCallbackSourceID( eDamageSourceId.mp_weapon_super_spectre, NerfReaperRocket )
	
	// ai deaths
	//AddDeathCallback( "npc_super_spectre", ReaperDeath ) // can' handle
}


////////////////////////////////
///// NPC CONFIG FUNCTIONS /////
////////////////////////////////

void function GruntModeHighlight( entity ent )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 1, 0, < 2,2,2 > )

	// for npc pilots and titans, we save their enemy highlights
	string className = ent.GetClassName()
	switch ( className )
	{
		case "npc_pilot_elite":
			ent.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
			Highlight_SetEnemyHighlight( ent, "enemy_player" )
			break
		case "npc_titan":
		case "npc_super_spectre":
		case "npc_gunship":
			ent.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
			Highlight_SetEnemyHighlight( ent, "enemy_titan" )
			break
	}
}

void function GruntConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )

	string aiSetName = soldier.GetAISettingsName()
	// normal grunts, specialist grunt health handled by spawn function
	if ( aiSetName != "npc_soldier_shield_captain" && aiSetName != "npc_soldier_pve_specialist" )
	{
		soldier.SetMaxHealth( 80 )
		soldier.SetHealth( 80 )
		// hide name if they're not specialist
		thread TryHideNameLifeLong( soldier ) // grunts may spawn from dropship, they'll still show name, so do a loop
	}
	else // specialist
		soldier.SetTitle( GetMilitiaTitle() ) // funny in _ai_soldiers.gnut

	Melee_SetHumanSizedDoClassicExecution( soldier, true ) // grunts uses classic neck snap
}

void function TryHideNameLifeLong( entity guy )
{
	guy.EndSignal( "OnDestroy" )
	guy.EndSignal( "OnDeath" )
	while ( true )
	{
		guy.SetNameVisibleToEnemy( false )
		WaitFrame()
	}
}

void function PilotConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )
}

void function MarvinConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )

	soldier.SetMaxHealth( 300 )
	soldier.SetHealth( 300 )

	soldier.SetNameVisibleToEnemy( false )

	soldier.SetNoTarget( true ) // don't want other npcs targeting them
}

void function ProwlerConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )

	// so they won't block teammates
	soldier.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER

	soldier.SetNameVisibleToEnemy( false )
}

void function SpectreConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )

	soldier.SetMaxHealth( 190 )
	soldier.SetHealth( 190 )

	soldier.SetNameVisibleToEnemy( false )

	DisableLeeching( soldier ) // grunts can't leech
}

void function StalkerConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )

	soldier.SetMaxHealth( 280 )
	soldier.SetHealth( 280 )

	soldier.SetNameVisibleToEnemy( false )
}

void function ReaperConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )

	// even stronger
	soldier.SetMaxHealth( 4500 ) // was 5500, we have 2 reapers now...
	soldier.SetHealth( 4500 )
}

void function TitanConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )
}

void function DroneConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )

	soldier.SetNameVisibleToEnemy( false )
}

void function GunshipConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )
	// lower health since they'll become noTarget
	soldier.SetMaxHealth( 5500 )
	soldier.SetHealth( 5500 )

	soldier.SetNoTarget( true ) // don't want other npcs targeting them
}

void function DropshipConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )

	soldier.SetNoTarget( true ) // don't want other npcs targeting them
}

void function TickConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )

	// enemy highlight
	Highlight_SetEnemyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 2, 0, < 2,0,0 > )

	soldier.SetNameVisibleToEnemy( false )
}

void function TurretConfig( entity soldier )
{
	// friendly highlight
	Highlight_SetFriendlyHighlight( soldier, "sp_enemy_pilot" )
	soldier.Highlight_SetParam( 1, 0, < 2,2,2 > )
	
	soldier.SetNameVisibleToEnemy( false )
}

////////////////////////////////////
///// NPC CONFIG FUNCTIONS END /////
////////////////////////////////////



////////////////////////////////
///// NPC DAMAGE FUNCTIONS /////
////////////////////////////////

void function BuffPilotDamage( entity victim, var damageInfo )
{
	if ( victim.GetArmorType() != ARMOR_TYPE_HEAVY ) // not a heavy armor target
	{
		// make npc pilots powerful?
		DamageInfo_SetDamage( damageInfo, DamageInfo_GetDamage( damageInfo ) * NPC_PILOT_DAMAGE_MULTIPLIER )
	}
}

void function NerfProwlerMelee( entity victim, var damageInfo )
{
	bool nerfDamage = false
	// prowler's craw damage is 80, pounce damage is 100
	if ( victim.IsPlayer() ) // nerf it's damage agains players
		nerfDamage = true

	if ( victim.IsNPC() )
	{
		// a npc owned by player, do reduce damage
		if ( IsValid( victim.GetBossPlayer() ) )
			nerfDamage = true
		if ( IsValid( victim.GetOwner() ) )
			nerfDamage = true
	}

	if ( nerfDamage )
		DamageInfo_SetDamage( damageInfo, DamageInfo_GetDamage( damageInfo ) * NPC_PROWLER_DAMAGE_MULTIPLIER )
}

void function NerfReaperRocket( entity victim, var damageInfo )
{
	if ( !victim.IsPlayer() || victim.IsTitan() ) // nerf the damage they dealt to humansized players
		return

	DamageInfo_SetDamage( damageInfo, DamageInfo_GetDamage( damageInfo ) * NPC_SUPER_SPECTRE_ROCKET_DAMAGE_MULTIPLIER )
}

////////////////////////////////////
///// NPC DAMAGE FUNCTIONS END /////
////////////////////////////////////



///////////////////////////////
///// NPC DEATH FUNCTIONS /////
///////////////////////////////

void function ReaperDeath( entity soldier, var damageInfo )
{
	if ( !IsValid( soldier ) ) // destroyed?
		return
	
	// ignite existing ticks
	string squadName = expect string ( soldier.kv.squadname ) // mostly can't handle!!!
	if ( squadName == "" ) // invalid squad
		return
	array<entity> ticks = GetNPCArrayBySquad( squadName )
	ticks.removebyvalue( soldier )
	foreach ( entity tick in ticks )
	{
		if ( IsAlive( tick ) )
			tick.Die() // hopefully they'll explode
	}
}

///////////////////////////////////
///// NPC DEATH FUNCTIONS END /////
///////////////////////////////////



//////////////////////////////
///// CALLBACK FUNCTIONS /////
//////////////////////////////

void function OnClientConnected( entity player )
{
	file.playerChatterTable[player.GetUID()] <- false
	file.playerClassTable[ player ] <- "" // empty class
	AddPlayerHeldButtonEventCallback( player, IN_USE, CallbackFuncCornerUs, 0.5 ) // was 0.3
	AddPlayerHeldButtonEventCallback( player, IN_USE_AND_RELOAD, CallbackFuncCornerUs, 0.5 ) // controller support
	AddButtonPressedPlayerInputCallback( player, IN_USE, CallbackFuncSpotEnemy )
	AddButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, CallbackFuncSpotEnemy ) // controller support
}

void function OnPlayerChangeLoadout( entity player , PilotLoadoutDef p )
{	
	BecomeGruntModePlayer( player )
	// older version of the function, pretty hard to modify
	//BecomesGrunt_Loadout( player )
}

void function OnPlayerRespawned( entity player )
{	
	if ( GetGameState() > eGameState.Prematch )
		SpawnFromDroppod( player, 6 ) // less droppod lifetime, hopefully reduce entity count
	//if( GetZiplineDropshipSpawns().len() != 0 )
	//	RespawnInDropShip( player ) // bugged
	//else
	//	SpawnFromDroppod( player, 5 )
	thread DisableBoostBar( player ) // don't know why this causes problem
}

void function DisableBoostBar( entity player )
{
	WaitFrame()
	if ( IsAlive( player ) )
		PlayerEarnMeter_SetMode( player, eEarnMeterMode.DISABLED )	// completely disable titan meter
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
	StartKillerOutline( victim, attacker )
	PlayEnemyKilledChatter( victim, attacker )
	PlayFriendlyKilledChatter( victim, attacker )
	//file.playerClassTable[ victim ] = "" // reset class, will break IsGruntModeSpecialistClass()
}

void function OnGamePrematch()
{
	InitGruntModeSpawnerSettings() // care package settings or something...

	// only tempfix has checked their validity before clean up
	/* // no need to clean up since spawnpoint has been fixed, or player will be able to shoot outside map
	foreach( entity trigger in GetEntArrayByClass_Expensive( "trigger_out_of_bounds" ) )
    {
		#if MP
			trigger.DisconnectOutput( "OnStartTouch", EntityEnterOutOfBoundsTrig )
			trigger.DisconnectOutput( "OnEndTouch", EntityLeaveOutOfBoundsTrig )
		#else
			trigger.DisconnectOutput( "OnStartTouch", EntityOutOfBounds )
			trigger.DisconnectOutput( "OnEndTouch", EntityBackInBounds )
		#endif
    }
	*/
}

//////////////////////////////////
///// CALLBACK FUNCTIONS END /////
//////////////////////////////////



///////////////////////////////////
///// GRUNT CHATTER FUNCTIONS /////
///////////////////////////////////

void function CallbackFuncCornerUs( entity player )
{
	thread CornerUsChatterThink( player )
}

void function CornerUsChatterThink( entity player )
{
	string uid = player.GetUID()
	if( file.playerChatterTable[uid] )
		return
	if( !IsAlive( player ) )
		return
	//print( "Setting Chatter Unusable" )
	string curChatter = GRUNT_CHATTERS[ RandomInt( GRUNT_CHATTERS.len() ) ]
	EmitSoundOnEntity( player, curChatter )
	thread DelayedRestoreBattleChatter( uid, 3 )
	//print( "Reset Chatter Usage" )
}

void function CallbackFuncSpotEnemy( entity player )
{
	thread SpotEnemyChatterThink( player )
}

void function SpotEnemyChatterThink( entity player )
{
	string uid = player.GetUID()
	if( file.playerChatterTable[uid] )
		return
	if( !IsAlive( player ) )
		return
	TraceResults traceResult = TraceLine( player.EyePosition(), player.EyePosition() + player.GetViewVector() * 65535, player, (TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), TRACE_COLLISION_GROUP_NONE )
	if( !IsValid( traceResult.hitEnt ) )
	{
		//print( "Didn't trace anything" )
		return
	}
	if( !traceResult.hitEnt.IsNPC() )
	{
		//print( "hitEnt wasn't npc" )
		return
	}
	if( traceResult.hitEnt.GetTeam() == player.GetTeam() )
		return
	array<string> chatterClasses = [ "npc_spectre", "npc_stalker", "npc_prowler", "npc_pilot_elite", "npc_titan" ]
	string className = traceResult.hitEnt.GetClassName()
	//print( "hitEnt's classname: " + className )
	if( !chatterClasses.contains( className ) )
		return
	switch( className )
	{
		case "npc_spectre":
			EmitSoundOnEntity( player, "diag_imc_grunt" + string( RandomIntRange( 1, 6 ) ) + "_bc_reactSpectreEnemyMid_0" + string( RandomIntRange( 1, 3 ) ) )
			thread DelayedRestoreBattleChatter( uid, 3 )
			break
		case "npc_stalker":
			EmitSoundOnEntity( player, "diag_imc_grunt" + string( RandomIntRange( 1, 6 ) ) + "_bc_engagingStalker_0" + string( RandomIntRange( 1, 2 ) ) )
			thread DelayedRestoreBattleChatter( uid, 3 )
			break
		case "npc_prowler":
			EmitSoundOnEntity( player, "diag_imc_grunt" + string( RandomIntRange( 1, 6 ) ) + "_bc_engagingProwler_0" + string( RandomIntRange( 1, 2 ) ) )
			thread DelayedRestoreBattleChatter( uid, 3 )
			break
		case "npc_pilot_elite":
			EmitSoundOnEntity( player, "diag_imc_grunt" + string( RandomIntRange( 1, 6 ) ) + "_bc_engagepilotenemy_0" + string( RandomIntRange( 1, 7 ) ) )
			thread DelayedRestoreBattleChatter( uid, 3 )
			break
		case "npc_titan":
			EmitSoundOnEntity( player, "diag_imc_grunt" + string( RandomIntRange( 1, 6 ) ) + "_bc_enemytitanspotcall_0" + string( RandomIntRange( 1, 2 ) ) )
			thread DelayedRestoreBattleChatter( uid, 5 )
			break
		case "npc_super_spectre":
			if( CoinFlip() )
				EmitSoundOnEntity( player, "diag_sp_ReaperTown_BM102_15_01_mcor_grunt3" )
			else
				EmitSoundOnEntity( player, "diag_sp_ReaperTown_BM102_16_01_mcor_grunt2" )
			thread DelayedRestoreBattleChatter( uid, 3 )
			break
	}
}

void function DelayedRestoreBattleChatter( string uid, float delay )
{
	file.playerChatterTable[uid] = true
	wait delay
	file.playerChatterTable[uid] = false
}

void function StartKillerOutline( entity victim, entity attacker )
{
	// may mess up highlights( client won't clean up npc's DeathRecapHighlight if player didn't entered killcam )
	//if( attacker.IsNPC() || attacker.IsPlayer() )
	//	Highlight_SetDeathRecapHighlight( attacker, "killer_outline" )
}

void function PlayEnemyKilledChatter( entity victim, entity attacker )
{
	if( victim.IsPlayer() && attacker.IsPlayer() )
		thread DelayedEnemyKilledChatter( attacker )
}

void function DelayedEnemyKilledChatter( entity player )
{
	string uid = player.GetUID()
	if( file.playerChatterTable[uid] )
		return
	wait RandomFloatRange( 0.3, 0.5 )
	if( IsAlive( player ) )
	{
		EmitSoundOnEntity( player, "diag_imc_grunt" + string( RandomIntRange( 1, 6 ) ) + "_bc_killenemygrunt_0" + string( RandomIntRange( 1, 2 ) ) )
	}
	thread DelayedRestoreBattleChatter( uid, 3 )
}

void function PlayFriendlyKilledChatter( entity victim, entity attacker )
{
	int team = victim.GetTeam()
	array<entity> nearbyAllies = GetPlayerArrayEx( "any", TEAM_ANY, TEAM_ANY, victim.GetOrigin(), 250 )
	foreach( entity player in nearbyAllies )
	{
		if( IsValid( player ) )
		{
			if( player.GetTeam() == team )
				thread DelayedFriendlyKilledChatter( player )
		}
	}
}

void function DelayedFriendlyKilledChatter( entity player )
{
	string uid = player.GetUID()
	if( file.playerChatterTable[uid] )
		return
	wait RandomFloatRange( 0.3, 0.5 )
	if( IsAlive( player ) )
	{
		array<entity> nearbyAllies = GetPlayerArrayEx( "any", player.GetTeam(), TEAM_ANY, player.GetOrigin(), 250 )
		if( nearbyAllies.len() == 0 )
		{
			EmitSoundOnEntity( player, "diag_imc_grunt" + string( RandomIntRange( 1, 6 ) ) + "_bc_squaddeplete" )
			thread DelayedRestoreBattleChatter( uid, 5 )
		}
		else
		{
			EmitSoundOnEntity( player, "diag_imc_grunt" + string( RandomIntRange( 1, 6 ) ) + "_bc_allygruntdown" )
			thread DelayedRestoreBattleChatter( uid, 3 )
		}
	}
}

///////////////////////////////////////
///// GRUNT CHATTER FUNCTIONS END /////
///////////////////////////////////////



///////////////////////////////////
///// GRUNT RESPAWN FUNCTIONS /////
///////////////////////////////////

void function BecomeGruntModePlayer( entity player )
{
	// pick a random class
	array<string> validClasses = GetGruntModeValidClasses()
	string selectedClassName = validClasses[ RandomInt( validClasses.len() ) ]
	PlayerClassStruct selectedClassStruct = file.gruntModeClasses[ selectedClassName ]
	// debugging
	//PlayerClassStruct selectedClassStruct = file.gruntModeClasses[ "Ravenant" ]

	file.playerClassTable[ player ] = selectedClassStruct.className
	selectedClassStruct.classLoadoutFunction( player ) // run loadout function
}

///////////////////////////////////////
///// GRUNT RESPAWN FUNCTIONS END /////
///////////////////////////////////////



//////////////////////////////////////////
///// EXTRASPAWNER SETTINGS FUNCTION /////
//////////////////////////////////////////

void function InitGruntModeSpawnerSettings()
{
	ExtraSpawner_SetNPCWeapons( "npc_pilot_elite", ["mp_weapon_rspn101_og", "mp_weapon_r97", "mp_weapon_car", "mp_weapon_alternator_smg", "mp_weapon_vinson"] )
	ExtraSpawner_SetNPCWeapons( "npc_stalker", ["mp_weapon_softball", "mp_weapon_smr"] ) // stalkers can't shoot "mp_weapon_pulse_lmg"
	ExtraSpawner_SetNPCAntiTitanWeapons( "npc_soldier", [ "mp_weapon_rocket_launcher", "mp_weapon_mgl" ] )
	ExtraSpawner_SetNPCAntiTitanWeapons( "npc_spectre", [ "mp_weapon_arc_launcher", "mp_weapon_defender" ] )

	ExtraSpawner_SetCarePackageWeapons( ["mp_weapon_epg", "mp_weapon_smr", "mp_weapon_softball", "mp_weapon_pulse_lmg"] )

	ExtraSpawner_SetCarePackageWeaponMods( "mp_weapon_epg", [] ) // was ["pas_run_and_gun"]
	ExtraSpawner_SetCarePackageWeaponMods( "mp_weapon_smr", [] ) // was ["extended_ammo"]
	ExtraSpawner_SetCarePackageWeaponMods( "mp_weapon_softball", [] ) // was ["extended_ammo"]
	ExtraSpawner_SetCarePackageWeaponMods( "mp_weapon_pulse_lmg", [] )

	AiDrone_SetDroneSpawnedByNPCRandomType( true ) // modified function in _ai_drone.nut, specialist grunts will spawn random drones
	AiSoldier_EnablePilotEngageChatter( false ) // modified function in _ai_soldiers.gnut, npcs won't call out if they meet players(since we want to make players grunts)
}

//////////////////////////////////////////////
///// EXTRASPAWNER SETTINGS FUNCTION END /////
//////////////////////////////////////////////



///////////////////////////////////
///// CLASS UTILITY FUNCTIONS /////
///////////////////////////////////

// shared func
void function GruntMode_RegisterPlayerClass( string className, void functionref( entity ) classLoadoutFunction, bool isSpecialist )
{
	if ( className in file.gruntModeClasses ) // already registered?
	{
		print( "[GRUNTMODE] " + className + " class has already been registered!" )
		return
	}
	PlayerClassStruct newCLass
	newCLass.className = className
	newCLass.classLoadoutFunction = classLoadoutFunction
	newCLass.isSpecialist = isSpecialist
	file.gruntModeClasses[ className ] <- newCLass
}

// shared func
bool function GruntMode_IsSpecialistClass( entity player )
{
	if ( !( player in file.playerClassTable ) )
		return false
	string className = file.playerClassTable[ player ]
	if ( !( className in file.gruntModeClasses ) )
		return false
	// find player's class
	PlayerClassStruct playerClass = file.gruntModeClasses[ className ]
	return playerClass.isSpecialist
}

array<string> function GetGruntModeValidClasses()
{
	array<string> classes
	foreach ( string className, PlayerClassStruct classStruct in file.gruntModeClasses )
	{
		//print( "[GRUNTMODE] found class: " + className )
		classes.append( className )
	}
	return classes
}


///////////////////////////////////////
///// CLASS UTILITY FUNCTIONS END /////
///////////////////////////////////////