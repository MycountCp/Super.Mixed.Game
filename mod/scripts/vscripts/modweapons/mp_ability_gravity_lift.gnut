// use a mover to lift a player could be better?

global function MpAbilityGravityLift_Init
global function OnWeaponTossReleaseAnimEvent_ability_gravity_lift
global function OnProjectileCollision_ability_gravity_lift

// Gravity Lift
const float LIFT_THROW_POWER_SCALE = 0.3
//const int LIFT_SEGMENT_COUNT = 10
//const float LIFT_HEIGHT_PER_SEGMENT = 50
const float LIFT_HEIGHT = 1200
const float LIFT_RADIUS = 120
const float LIFT_RISE_SPEED = 325
const float LIFT_HORIZON_MOVE_SPEED = 225
const float LIFT_AIR_ACCELERATION = 3000 // higher for better control
const float LIFT_PULL_SPEED_HORIZON = 350
//const float LIFT_PULL_SPEED_MULTIPLIER = 2
const float LIFT_PULL_SPEED_VERTICAl = 340
const float LIFT_TOP_TIME_LIMIT = 2
const float LIFT_LIFETIME = 10
const float LIFT_COOLDOWN = 0.0 // 0.5 // time between second lift, I guess it's no need for titanfall?

struct GravLiftSavedSettings
{
	float gravity
	float airAccel
	float airSpeed
}

struct
{
	table<entity, int> playerInGravLiftCount // for handling multiple gravlifts!
	table<entity, GravLiftSavedSettings> playerGravLiftSavedSettings // for we can recover player's settings after they leave lift
} file

void function MpAbilityGravityLift_Init()
{
	#if SERVER
		// add to some modifiers
		Grenade_AddCookDisabledMod( "gravity_lift" )
		Grenade_AddDropOnDeathDisabledMod( "gravity_lift" )

		RegisterSignal( "EnterGravityLift" )
		RegisterSignal( "LeaveGravityLift" )

		AddCallback_OnClientConnected( OnClientConnected )
	#endif
}


var function OnWeaponTossReleaseAnimEvent_ability_gravity_lift( entity weapon, WeaponPrimaryAttackParams attackParams )
{
	entity projectile = ThrowDeployable( weapon, attackParams, LIFT_THROW_POWER_SCALE, OnGravityLiftDeployed ) // less vec?
	// fix sound!
	string fpSound = string ( GetGrenadeThrowSound_1p( weapon ) )
	string tpSound = string ( GetGrenadeThrowSound_3p( weapon ) )
	weapon.EmitWeaponSound_1p3p( fpSound, tpSound )
	if ( projectile )
	{
		#if SERVER
		thread WaitForGravLiftDeployMent( weapon, projectile )
		// manage weapon cooldown
		thread GravLiftWeaponCooldown( weapon, projectile )
		#endif
	}

	return weapon.GetWeaponSettingInt( eWeaponVar.ammo_per_shot )
}

#if SERVER
void function OnClientConnected( entity player )
{
	file.playerInGravLiftCount[ player ] <- 0
}

void function WaitForGravLiftDeployMent( entity weapon, entity projectile )
{
	weapon.EndSignal( "OnDestroy" )
    projectile.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( weapon, projectile )
		{
			if ( !IsValid( weapon ) )
			{
				if ( IsValid( projectile ) )
					projectile.Destroy() // if weapon has been destroyed after deployment, destroy the projectile
			}
		}
	)

    projectile.WaitSignal( "Planted" )
}

void function GravLiftWeaponCooldown( entity weapon, entity projectile )
{
	weapon.EndSignal( "OnDestroy" )
	weapon.AddMod( "no_regen" ) // stop regen!

	// wait for projectile being destroyed
	projectile.WaitSignal( "OnDestroy" )
	weapon.RemoveMod( "no_regen" )
}
#endif

void function OnProjectileCollision_ability_gravity_lift( entity projectile, vector pos, vector normal, entity hitEnt, int hitbox, bool isCritical )
{
	#if SERVER
		entity owner = projectile.GetOwner()
		if( !IsAlive( owner ) )
		{
			if( IsValid( projectile ) ) // don't let a useless shuriken stay on ground
			{
				projectile.Destroy()
				return
			}
		}
	#endif

	OnProjectileCollision_weapon_deployable( projectile, pos, normal, hitEnt, hitbox, isCritical )
}

void function OnGravityLiftDeployed( entity projectile )
{
	#if SERVER
	thread GravityLiftThink( projectile )

	// now using a new check!
	//thread GravityLiftThink( projectile )
	#endif
}

#if SERVER
void function GravityLiftThink( entity projectile )
{
	projectile.Hide() // don't show the shuriken to player
	EmitSoundOnEntity( projectile, "default_gravitystar_impact_3p" )

	entity gravLiftBeam = StartParticleEffectOnEntity_ReturnEntity( projectile, GetParticleSystemIndex( FX_HARVESTER_BEAM ), FX_PATTACH_ABSORIGIN_FOLLOW, 0 )
	gravLiftBeam.DisableHibernation() // prevent it from fading out( will leave a red destroyed beam! )
	EffectSetControlPointVector( gravLiftBeam, 1, < 0,100,255 > ) // purly blue

	// maybe not a good idea to use "trigger_cylinder", for they're too sensitive about z values
	/* // setup trigger
	entity trigger = CreateEntity( "trigger_cylinder" )
	trigger.SetRadius( LIFT_RADIUS )
	trigger.SetAboveHeight( LIFT_HEIGHT + 200 ) // set a bit higher, this is not a single scriptRef anymore
	trigger.SetBelowHeight( -1 )
	trigger.SetOrigin( projectile.GetOrigin() )

	trigger.SetEnterCallback( OnGravityLiftTriggerEnter )
	trigger.SetLeaveCallback( OnGravityLiftTriggerLeave )
	DispatchSpawn( trigger )
	*/

	entity trigger = CreateTriggerRadiusMultiple( projectile.GetOrigin(), LIFT_RADIUS, [], TRIG_FLAG_START_DISABLED | TRIG_FLAG_NO_PHASE_SHIFT, LIFT_HEIGHT, -1 )
	//trigger.SetParent( projectile, "ORIGIN" )

	AddCallback_ScriptTriggerEnter( trigger, OnGravityLiftTriggerEnter )
	AddCallback_ScriptTriggerLeave( trigger, OnGravityLiftTriggerLeave )

	ScriptTriggerSetEnabled( trigger, true )

	thread GravityLiftLifeTime( projectile, trigger, gravLiftBeam )
}

void function GravityLiftLifeTime( entity projectile, entity trigger, entity gravLiftBeam )
{
	projectile.EndSignal( "OnDestroy" )
	trigger.EndSignal( "OnDestroy" )
	gravLiftBeam.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( projectile, trigger, gravLiftBeam )
		{
			// this handles IsValid() checks
			thread DestroyGravityLift( projectile, trigger, gravLiftBeam )
		}
	)

	float endTime = Time() + LIFT_LIFETIME
	float maxEndTime = Time() + ( LIFT_LIFETIME * 1.5 ) // for players staying on it, it will try it's best to keep alive
	while ( true )
	{
		array<entity> inLiftEntities = GetAllEntitiesInTrigger( trigger )
		array<entity> inLiftPlayers
		foreach ( entity ent in inLiftEntities )
		{
			if ( !IsValid( ent ) ) // this could happen!
				continue
			if ( ent.IsPlayer() )
				inLiftPlayers.append( ent )
		}

		// reached lifetime with no players inside
		if( Time() > endTime && inLiftPlayers.len() == 0 )
		{
			break
		}
		// reached lifetime with players inside, will keep lifting for another .5 times
		else if( Time() > maxEndTime )
		{
			break
		}

		WaitFrame()
	}
}

void function DestroyGravityLift( entity projectile, entity trigger, entity gravLiftBeam )
{
	if( IsValid( gravLiftBeam ) )
	{
		gravLiftBeam.kv.Visibilityflags = 0 // first hide, then destroy, or it will show a harvester destroyed fx
		wait 0.1
		if ( IsValid( gravLiftBeam ) ) // anti crash
			EffectStop( gravLiftBeam )
	}
	if( IsValid( projectile ) )
		projectile.Destroy()
	if( IsValid( trigger ) )
		trigger.Destroy()
}

void function OnGravityLiftTriggerEnter( entity trigger, entity ent )
{
	// only affects pilots, npcs, prop_physics and grenades
	if( ent.IsTitan() )
		return
	string className = ent.GetClassName()
	if ( !ent.IsNPC() && !ent.IsPlayer() && !( className == "prop_physics" ) && !( className == "grenade" ) )
		return

	bool firstEnterLift = true
	if ( ent.IsPlayer() )
	{
		if ( file.playerInGravLiftCount[ ent ] > 0 ) // not first lift
			firstEnterLift = false
	}

	if ( firstEnterLift )
	{
		ent.Signal( "EnterGravityLift" ) // this will end other gravlifts
		if ( ent.IsPlayer() ) // save settings for player
			file.playerGravLiftSavedSettings[ ent ] <- SaveSettingsForPlayerEnterLift( ent )
	}
	if ( ent.IsPlayer() )
		file.playerInGravLiftCount[ ent ] += 1
	thread EntityInGravityLift( ent, trigger )
}

void function OnGravityLiftTriggerLeave( entity trigger, entity ent )
{
	//if( ent.IsTitan() )
	//	return

	bool shouldEndLift = true
	if ( ent.IsPlayer() )
	{
		if ( file.playerInGravLiftCount[ ent ] > 1 ) // still have other lifts left
			shouldEndLift = false
	}
	
	if ( shouldEndLift )
	{
		ent.Signal( "LeaveGravityLift" ) // this will end other gravlifts
		if ( ent.IsPlayer() ) // restore settings for player
			RestorePlayerSavedSettings( ent )
	}
	if ( ent.IsPlayer() )
		file.playerInGravLiftCount[ ent ] -= 1
}

GravLiftSavedSettings function SaveSettingsForPlayerEnterLift( entity player )
{
	// save ent's gravity or some other keyvalues for later restoring
	GravLiftSavedSettings newSettings
	newSettings.gravity = float( player.kv.gravity )
	newSettings.airAccel = float( player.kv.airAcceleration )
	newSettings.airSpeed = float( player.kv.airSpeed )
	return newSettings
}

bool function RestorePlayerSavedSettings( entity player )
{
	if ( !( player in file.playerGravLiftSavedSettings ) ) // no saved settings!
		return false
	GravLiftSavedSettings savedSettings = file.playerGravLiftSavedSettings[ player ]
	player.kv.gravity = savedSettings.gravity
	player.kv.airAcceleration = savedSettings.airAccel
	player.kv.airSpeed = savedSettings.airSpeed

	// clean up
	delete file.playerGravLiftSavedSettings[ player ]
	return true
}

void function EntityInGravityLift( entity ent, entity trigger )
{
	trigger.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDestroy" )
	if ( ent.IsPlayer() || ent.IsNPC() ) // these entities may die
		ent.EndSignal( "OnDeath" )
	ent.EndSignal( "EnterGravityLift" )
	ent.EndSignal( "LeaveGravityLift" )

	int visualStatusEffect = -1
	if ( ent.IsPlayer() ) // add a bit visual effect for player
		visualStatusEffect = StatusEffect_AddEndless( ent, eStatusEffect.emp, 0.05 )

	table storedStats = 
	{
		gravity = float( ent.kv.gravity ) // npc specific
		lastTickVel = < 0, 0, 0 > // player specific
	}

	table results = {} // save some behaviors
	results.bouncedFromLift <- false // bool, to get if the entity is leaving the lift manually or being bounced away

	OnThreadEnd(
		function(): ( ent, trigger, visualStatusEffect, storedStats, results )
		{
			if ( IsValid( ent ) ) // any valid ent should be restore gravity or someother keyvalues
			{
				// player specifics
				if ( ent.IsPlayer() ) 
				{
					if ( visualStatusEffect > -1 )
						StatusEffect_Stop( ent, visualStatusEffect )

					ent.UnforceStand()
					ent.TouchGround() // restore one doublejump!
					StopSoundOnEntity( ent, "titan_flight_hover_3p" ) // clear existing sound
				}
				else // npcs
					ent.kv.gravity = storedStats.gravity
			}
			if ( IsAlive( ent ) ) // only living ent will be push away
			{
				if ( ent.IsPlayer() )
				{
					if ( file.playerInGravLiftCount[ ent ] > 1 ) // still having other gravlifts!
						return // don't bounce
				}

				// consider this means the entity is force bounced away, or trigger caused them being force bounced
				if ( ent.IsNPC() || results.bouncedFromLift || !IsValid( trigger ) ) 
					BounceEntityForward( ent )
				else
					BouncePlayerFromLift( ent, expect vector( storedStats.lastTickVel ) ) // last tick's velocity can mostly get player's move direction
			}
		}
	)

	float bottomHeight = trigger.GetOrigin().z
	float topHeight = bottomHeight + LIFT_HEIGHT

	bool reachedHighest = false
	float reachHighestTime // for saving reach highest part's time

	// sound for player lifting
	if ( ent.IsPlayer() )
	{
		StopSoundOnEntity( ent, "titan_flight_hover_3p" ) // clear existing sound
		EmitSoundOnEntity( ent, "titan_flight_hover_3p" )
	}

	// update air speed here
	ent.kv.airSpeed = LIFT_HORIZON_MOVE_SPEED
	ent.kv.airAcceleration = LIFT_AIR_ACCELERATION

	bool firstLoop = true
	while( true ) // start lifting entity
	{
		if ( !firstLoop )
			firstLoop = false
		else
			WaitFrame()

		// keep updating velocity
		if ( ent.IsPlayer() )
			storedStats.lastTickVel = ent.GetVelocity()

		//bool shouldLiftEnt = true
		// check if we need to lift the ent
		if ( ent.IsPlayer() )
		{
			//print( file.playerInGravLiftCount[ ent ] )
			// don't lift wallrunning/wallhanging/wallclimbing/ziplining players
			if ( ent.IsWallRunning() || ent.IsWallHanging() || ent.IsTraversing() || ent.IsZiplining() )
				continue
		}
		if ( IsValid( ent.GetParent() ) ) // has a parent
			continue

		if( !reachedHighest )
		{
			// lift the entity
			ent.kv.gravity = 0.0001 // never uses 0.0, it means default gravity
			vector airSpeed = ent.GetVelocity() //GetEntityGravLiftVelocity( ent, LIFT_HORIZON_MOVE_SPEED )
			airSpeed.z = LIFT_RISE_SPEED
			if ( ent.IsPlayer() && PlayerNotDoingInput( ent ) ) // not doing any input
				airSpeed = RemoveVelocityHorizonal( airSpeed )
			else
				airSpeed = LimitVelocityHorizontal( airSpeed, LIFT_HORIZON_MOVE_SPEED )
			ent.SetVelocity( airSpeed )
		}
		else // reached highest!
		{
			// make entity floating
			vector airSpeed = ent.GetVelocity() //GetEntityGravLiftVelocity( ent, LIFT_HORIZON_MOVE_SPEED )
			airSpeed.z = 0
			if ( ent.IsPlayer() && PlayerNotDoingInput( ent ) ) // not doing any input
				airSpeed = RemoveVelocityHorizonal( airSpeed )
			else
				airSpeed = LimitVelocityHorizontal( airSpeed, LIFT_HORIZON_MOVE_SPEED )
			ent.SetVelocity( airSpeed )
			if ( Time() > reachHighestTime + LIFT_TOP_TIME_LIMIT ) // more than limit!
			{
				if ( ent.IsPlayer() )
				{
					if ( file.playerInGravLiftCount[ ent ] > 1 ) // still having other gravlifts! )
						continue
				}
				results.bouncedFromLift = true // consider as force bounced away!
				break // end the loop
			}
		}

		// highest parts check
		if( ent.GetOrigin().z - bottomHeight >= LIFT_HEIGHT && !reachedHighest )
		{
			reachHighestTime = Time()
			reachedHighest = true
		}

		if ( ent.IsPlayer() )
		{
			ent.ForceStand() // force player to stand
			ent.ConsumeDoubleJump() // don't let players doublejump
			FindNearestSafeSpotAndPutEntity( ent, 1 ) // always try to protect players from stucking
		}
	}
}

vector function LimitVelocityHorizontal( vector vel, float speed )
{
	vector horzVel = <vel.x, vel.y, 0>
	if ( Length( horzVel ) <= speed )
		return vel

	horzVel = Normalize( horzVel )
	horzVel *= speed
	vel.x = horzVel.x
	vel.y = horzVel.y
	return vel
}

vector function RemoveVelocityHorizonal( vector vel )
{
    vector horzVel = <vel.x, vel.y, 0>

    float speed = 0.0
	horzVel = Normalize( horzVel )
	horzVel *= speed
	vel.x = horzVel.x
	vel.y = horzVel.y
	return vel
}

bool function PlayerNotDoingInput( entity player )
{
	vector inputVec = GetPlayerVelocityFromInput( player, 1 )
    vector inputAngs = VectorToAngles( inputVec )
    inputAngs.x = 0
    inputAngs.y -= 180
    //print( inputAngs )
	return inputAngs.x == 0 && inputAngs.y == 0
}

void function BouncePlayerFromLift( entity player, vector lastTickVel ) // last tick's velocity can mostly get player's move direction
{
	vector airSpeed = GetPlayerHorizontalSpeedForced( lastTickVel, LIFT_PULL_SPEED_HORIZON )
	airSpeed.z = LIFT_PULL_SPEED_VERTICAl
	player.SetVelocity( airSpeed )
}

vector function GetPlayerHorizontalSpeedForced( vector moveVel, float speed )
{
	vector horzVel = <moveVel.x, moveVel.y, 0>

	horzVel = Normalize( horzVel )
	horzVel *= speed
	moveVel.x = horzVel.x
	moveVel.y = horzVel.y

	return moveVel
}

void function BounceEntityForward( entity ent )
{
	vector airSpeed
	if ( ent.IsPlayer() ) // player specifics
	{
		vector playerAngles = ent.EyeAngles()
		vector forward = AnglesToForward( < 0, playerAngles.y, 0 > ) // yaw only
		airSpeed = forward * LIFT_PULL_SPEED_HORIZON
		airSpeed.z = LIFT_PULL_SPEED_VERTICAl
	}
	else
	{
		airSpeed = ent.GetForwardVector() * LIFT_PULL_SPEED_HORIZON
		airSpeed.z = LIFT_PULL_SPEED_VERTICAl
	}

	ent.SetVelocity( airSpeed )
}

/* // unused, pretty bad to control
void function BounceEntityFromLift( entity ent )
{
	vector airSpeed = GetEntityGravLiftVelocity( ent, 1 ) * LIFT_PULL_SPEED_HORIZON
	airSpeed.z = LIFT_PULL_SPEED_VERTICAl
	ent.SetVelocity( airSpeed )
}

vector function GetEntityGravLiftVelocity( entity ent, float speed )
{
	if ( ent.IsPlayer() ) // for players, get their input!
		return GetPlayerVelocityFromInput( ent, speed )

	// other conditions
	return ent.GetUpVector() * speed
}
*/

vector function GetPlayerVelocityFromInput( entity player, float speed )
{
	vector angles = player.EyeAngles()
	float xAxis = player.GetInputAxisRight()
	float yAxis = player.GetInputAxisForward()
	vector directionForward = GetDirectionFromInput( angles, xAxis, yAxis )

	return directionForward * speed
}

vector function GetDirectionFromInput( vector playerAngles, float xAxis, float yAxis )
{
	playerAngles.x = 0
	playerAngles.z = 0
	vector forward = AnglesToForward( playerAngles )
	vector right = AnglesToRight( playerAngles )

	vector directionVec = Vector(0,0,0)
	directionVec += right * xAxis
	directionVec += forward * yAxis

	vector directionAngles = VectorToAngles( directionVec )
	vector directionForward = AnglesToForward( directionAngles )

	return directionForward
}
#endif