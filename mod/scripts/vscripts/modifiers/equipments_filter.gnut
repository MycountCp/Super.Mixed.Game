untyped
global function EquipmentsFilter_Init

global function IgnoreEquipmentsFilter // "Offhand", "Main", "All", "None"
global function FilterWeapon

global function SetEquipmentsFilterList

global struct Weapon
{
	string weapon
	array<string> mods
}

const bool WHITELIST = false
const bool BLACKLIST = true
const bool FILTER_TYPE = BLACKLIST

const Weapon PRIMARY = { weapon = "mp_weapon_rspn101_og", mods = ["extended_ammo", "pas_fast_reload", "hcog"] }
const Weapon SECONDARY = { weapon = "mp_weapon_defender", mods = ["pas_fast_swap", "pas_fast_ads"] }
const Weapon BACKUP = { weapon = "mp_weapon_autopistol", mods = ["extended_ammo", "pas_fast_reload"] }
const Weapon GRENADE = { weapon = "mp_weapon_thermite_grenade", mods = [] }
const Weapon TACTICAL = { weapon = "mp_ability_grapple", mods = [] }
const Weapon MELEE = { weapon = "melee_pilot_kunai", mods = [] }
const bool MELEESWITCH = false

const array<string> DEFAULT_WEAPONS_LIST = 
[
	"mp_ability_cloak", 
	"mp_weapon_deployable_cover", 
	"mp_weapon_frag_grenade", 
	"mp_weapon_grenade_gravity", 
	"mp_weapon_satchel", 
	"mp_weapon_dmr", 
	"mp_weapon_lmg", 
	"mp_weapon_g2"
]

const array<string> DISABLED_BOOSTS_LIST =
[
	"burnmeter_smart_pistol", 
	"burnmeter_ap_turret_weapon"
]

const array<string> CONNECTING_NOTIFICATIONS = 
[
	"村规PVP服务器，禁用了部分可能引起争议的装备\n武器禁用：长弓DMR、喷火枪、G2\n技能禁用：隐身、A盾\n重火力禁用：破片手雷、重力星、炸药包\n强化卡禁用：智慧手枪、铁驭哨兵",
]

struct
{
	string ignoreFilterType = "None"
	array<string> filterList = DEFAULT_WEAPONS_LIST // default
} file

void function EquipmentsFilter_Init()
{
	HackedDeath_SetEnabled( true ) // powerful thing, no any screen blur and flash on death

	// enable normal settings, since this modifier didn't change so many things
	Nessie_Normal_Settings_NonTitan_Init()
	SetDeathCamLengthForced( 2.0 ) // shorter death cam

	// filter specific settings
	SetShouldFUCKOFFCLOAK( true )
	SetShouldFUCKOFFAWALL( true )
	Burnmeter_SetRewardsDisabled( DISABLED_BOOSTS_LIST ) // modified function in _burnmeter.gnut
	if( !MELEESWITCH )
		Melee_SetSyncedMeleeNoLimit( true ) // modified function in sh_melee.gnut, so player can do synced melee with no limit( even with no melee weapon )
	Nessie_SetHoloSprayEnabled( true ) // 
	// using baseForcedPlaylist "Pilot", so it can be overwrited by RandomGamePilot
	ForcedPlaylist_SetPlaylistTypeOverrides( "Pilot" ) // this one has support for now, using it
	//ForcedPlaylist_Disabled( true ) // overrides base forced playlist
	
	AddCallback_OnClientConnected( OnClientConnected )
	AddCallback_OnPlayerRespawned( OnPlayerRespawned ) // respawn not giving loadout, which will mess things up
	AddCallback_GameStateEnter( eGameState.Playing, OnGameStart )
	AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerChangeLoadout )
	//AddCallback_GameStateEnter( eGameState.Postmatch, OnGamePostmatch ) // removed for now, baseForcedPlaylist now has support on this
}

void function SetEquipmentsFilterList( array<string> list )
{
	file.filterList = list
}

void function IgnoreEquipmentsFilter( string ignoreType )
{
	file.ignoreFilterType = ignoreType
	if( ignoreType == "Offhand" || ignoreType == "All" )
	{
		SetShouldFUCKOFFCLOAK( false ) // bind together, also disable model limit
		SetShouldFUCKOFFAWALL( false )
	}
}

void function OnClientConnected( entity player )
{
	foreach ( string message in CONNECTING_NOTIFICATIONS )
		Chat_ServerPrivateMessage( player, message, false )
}

void function OnPlayerRespawned( entity player )
{
	//FilterWeapon( player )
	//player.SetAimAssistAllowed( false )
	//script foreach( entity player in GetPlayerArray() ){ player.SetAimAssistAllowed( false ) }
}

void function OnPlayerChangeLoadout( entity player , PilotLoadoutDef p)
{
	FilterWeapon( player )
}

void function OnGameStart()
{
	SetPlayerDeathsHidden( true ) // let's not count player's deaths!
    // change settings here to prevent being overwriten
    // be sure to set much higher prop limit
    //Nessie_SetWorldMaxNessieCount( 80 )
    //Rodeo_SetWorldBatteryMaxCount( 80 )
    //HoloSpray_SetMaxCountPerPlayer( 4 )
}

void function OnGamePostmatch()
{
	thread FilterForcedPlaylist()
}

void function FilterWeapon( entity player )
{
	if( file.ignoreFilterType == "All" ) // some random event will set this to not influence their loadouts
		return

 	bool hasAllowedWeapon = false

	if( file.ignoreFilterType != "Main" )
	{
		foreach ( int enum_, entity weapon in player.GetMainWeapons() )
		{
			if ( FILTER_TYPE == IsOnList( weapon.GetWeaponClassName() ) )
			{
				player.TakeWeaponNow( weapon.GetWeaponClassName() )

				switch ( enum_ ) 
				{
					case 0:
						if ( PRIMARY.weapon != "")
							player.GiveWeapon( PRIMARY.weapon, PRIMARY.mods )
						break
					case 1:
						if ( SECONDARY.weapon != "")
							player.GiveWeapon( SECONDARY.weapon, SECONDARY.mods	)
						break
					case 2:
						if ( BACKUP.weapon != "")
							player.GiveWeapon( BACKUP.weapon, BACKUP.mods )
						break
					default:
						break
				}
			}
		}
	}

	if( file.ignoreFilterType != "Offhand" )
	{
		foreach( int enum_, entity weapon in player.GetOffhandWeapons() )
		{
			player.TakeWeaponNow( "melee_pilot_emptyhanded" )
			if( MELEESWITCH )
				player.GiveOffhandWeapon( MELEE.weapon, OFFHAND_MELEE, MELEE.mods )

			if( FILTER_TYPE == IsOnList( weapon.GetWeaponClassName() ) )
			{
				player.TakeWeaponNow( weapon.GetWeaponClassName() )

				switch( enum_ )
				{
					case 0:
						if( GRENADE.weapon != "" )
							player.GiveOffhandWeapon( GRENADE.weapon, OFFHAND_ORDNANCE, GRENADE.mods )
						break
					case 1:
						if( TACTICAL.weapon != "" )
							player.GiveOffhandWeapon( TACTICAL.weapon, OFFHAND_SPECIAL, TACTICAL.mods )
						break
					default:
						break
				}
			}
		}
	}
}

bool function IsOnList( string w )
{
	foreach ( weapon in file.filterList ) 
	{
		if ( weapon == w )	
			return true
	}
	return false
}

// not using right now
void function FilterForcedPlaylist()
{
	string curMapName = GetMapName()
    wait 5
    switch( curMapName )
    {
        case "mp_glitch":
            ServerCommand( "map mp_colony02" )
			break
        case "mp_colony02":
            ServerCommand( "map mp_wargames" )
			break
        case "mp_wargames":
            ServerCommand( "map mp_eden" )
			break
        case "mp_eden":
            ServerCommand( "map mp_drydock" )
			break
        case "mp_drydock":
            ServerCommand( "map mp_black_water_canal" )
			break
        case "mp_black_water_canal":
            ServerCommand( "map mp_thaw" )
			break
        case "mp_thaw":
            ServerCommand( "map mp_grave" )
			break
        case "mp_grave":
            ServerCommand( "map mp_homestead" )
			break
        case "mp_homestead":
            ServerCommand( "map mp_forwardbase_kodai" )
			break
        case "mp_forwardbase_kodai":
            ServerCommand( "map mp_angel_city" )
			break
        case "mp_angel_city":
			ServerCommand( "map mp_relic02" )
			break
            //ServerCommand( "map mp_complex3" )
			//break
		//case "mp_complex3":
            //ServerCommand( "map mp_relic02" )
			break
		case "mp_relic02":
            ServerCommand( "map mp_glitch" )
			break
		// if start with lf maps, then loop it!
		case "mp_lf_stacks":
            ServerCommand( "map mp_lf_meadow" )
			break
		case "mp_lf_meadow":
            ServerCommand( "map mp_lf_deck" )
			break
		case "mp_lf_deck":
            ServerCommand( "map mp_lf_traffic" )
			break
		case "mp_lf_traffic":
            ServerCommand( "map mp_lf_township" )
			break
		case "mp_lf_township":
            ServerCommand( "map mp_lf_uma" )
			break
		case "mp_lf_uma":
            ServerCommand( "map mp_lf_stacks" )
			break
		default:
            ServerCommand( "map mp_glitch" )
    }
}