global function Nessie_Funny_Functions_Init

global function RGB_Hightlight
global function TitleFlash

global function RainbowPlayerSkin
global function RainbowWeaponSkin

global function RGY_BatterySkin
global function HoloFlash_Loop
global function HoloFlash

global function PlayerPulseBladeModel_HideBodyAndLegs
global function CreatePulseBladeHead
global function CreateWoundedHead
global function BindPulseBladeHeadToPlayer
global function BindeWoundedHeadToPlayer
global function CreateHumanGib
global function BecomeApexLegend
global function CreateRainbowDomeShield

global function NukeIncomingEffectForPlayer

global function CreateRocketTurret
global function CreateRemoteTurret

void function Nessie_Funny_Functions_Init()
{
	// precaching
	PrecacheModel( ROCKET_TURRET_MODEL )
	// signals
    RegisterSignal( "StartRGBHighlight" )
	RegisterSignal( "EndRGBHighlight" )
    RegisterSignal( "StartSBTitle" )
	RegisterSignal( "EndSBTitle" )
	RegisterSignal( "StartRainbowPlayer" )
	RegisterSignal( "EndRainbowPlayer" )
	RegisterSignal( "StartRainbowWeapon" )
	RegisterSignal( "EndRainbowWeapon" )
	RegisterSignal( "StartRGYBattery" )
	RegisterSignal( "EndRGYBattery" )
	RegisterSignal( "StartHoloFlash" )
	RegisterSignal( "EndHoloFlash" )
	RegisterSignal( "NukeIncomingEffect" )

	//AddClientCommandCallback( "rainbowdome", CC_SpawnRainbowDome )
	//AddClientCommandCallback( "nessyoutfit", CC_SpawnNessyOutfit )

	AddClientCommandCallback( "rgbself", SelfRGBHighlight )
	//AddClientCommandCallback( "sbself", SelfIMSBTitle )
	AddClientCommandCallback( "special", CC_GiveSpecialLoadout )

	//AddClientCommandCallback( "spawngib", SpawnHumanGib ) 
	//AddClientCommandCallback( "spawnmri", CC_SpawnPilotMri )

	//AddClientCommandCallback( "rocketturret", CC_CreateRocketTurret )
	//AddClientCommandCallback( "remoterocket", CC_CreateRocketRemoteTurret )
	//AddClientCommandCallback( "remoteplasma", CC_CreatePlasmaRemoteTurret )
	//AddClientCommandCallback( "remotesentry", CC_CreateSentryRemoteTurret )
}

// client commands
bool function CC_SpawnRainbowDome( entity player, array<string> args )
{
	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	CreateRainbowDomeShield( player.GetOrigin(), < 0,0,0 >, -1 )
	return true
}

bool function CC_SpawnNessyOutfit( entity player, array<string> args )
{
	SpawnNessyOutfit( player )
	return true
}

bool function SelfRGBHighlight( entity player, array<string> args )
{
	//if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
	//	return false

	thread RGB_Hightlight( player, true )
	return true
}

bool function SelfIMSBTitle( entity player, array<string> args )
{
	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	thread TitleFlash( player )
	return true
}

bool function CC_GiveSpecialLoadout( entity player, array<string> args )
{
	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

		
	return true
}
//

void function RGB_Hightlight( entity ent, bool showToAll = false, bool alwaysShow = false )
{
	OnThreadEnd(
		function(): ( ent )
		{
			if( IsValid( ent ) )
			{
				Highlight_ClearFriendlyHighlight( ent )
				Highlight_ClearEnemyHighlight( ent )
				Highlight_ClearNeutralHighlight( ent )
			}
		}
	)
	ent.Signal( "StartRGBHighlight" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartRGBHighlight" )
	ent.EndSignal( "EndRGBHighlight" )
	
	string highlightToUse = "sp_enemy_pilot" // normal one
	if ( alwaysShow )
		highlightToUse = "sp_friendly_hero" // this one will show across walls

	Highlight_SetFriendlyHighlight( ent, highlightToUse )
	if( showToAll )
	{
		Highlight_SetEnemyHighlight( ent, highlightToUse )
		Highlight_SetNeutralHighlight( ent, highlightToUse )
	}
	array<vector> colorArray = [ < 255,0,0 >, < 0,255,0 >, < 0,0,255 > ]
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == colorArray.len() - 1 ? 0 : index + 1

		ent.Highlight_SetParam( 1, 0, colorArray[index] ) // friendly
		if( showToAll )
		{
			ent.Highlight_SetParam( 2, 0, colorArray[index] ) // enemy
			ent.Highlight_SetParam( 0, 0, colorArray[index] ) // neutral
		}
	}
}

void function TitleFlash( entity ent, array<string> titleArray = [ "我是傻逼", "傻逼是我" ] )
{
	if ( titleArray.len() <= 0 ) // no title given
		return
	ent.Signal( "StartSBTitle" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartSBTitle" )
	ent.EndSignal( "EndSBTitle" )

	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == titleArray.len() - 1 ? 0 : index + 1

		ent.SetTitle( titleArray[index] )
	}
}

void function RainbowPlayerSkin( entity player )
{
	if( !PilotModelSupportsCamo( player ) )
		return
	player.Signal( "StartRainbowPlayer" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartRainbowPlayer" )
	player.EndSignal( "EndRainbowPlayer" )

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		player.SetSkin( 1 )
		player.SetCamo( camoIndexArray[index] )
	}
}


array<asset> PILOT_MODELS_SUPPORTS_CAMO =
[
	$"models/humans/pilots/pilot_medium_stalker_m.mdl",
	$"models/humans/pilots/pilot_medium_stalker_f.mdl",
	$"models/humans/pilots/pilot_light_ged_m.mdl",
	$"models/humans/pilots/pilot_light_ged_f.mdl",
	$"models/humans/pilots/pilot_light_jester_m.mdl",
	$"models/humans/pilots/pilot_light_jester_f.mdl",
	$"models/humans/pilots/pilot_medium_reaper_m.mdl"
	$"models/humans/pilots/pilot_medium_reaper_f.mdl",
	$"models/humans/pilots/pilot_medium_geist_m.mdl",
	$"models/humans/pilots/pilot_medium_geist_f.mdl",
	$"models/humans/pilots/pilot_heavy_roog_m.mdl",
	$"models/humans/pilots/pilot_heavy_roog_f.mdl",
	$"models/humans/pilots/pilot_heavy_drex_m.mdl",
	$"models/humans/pilots/pilot_heavy_drex_f.mdl"
]

bool function PilotModelSupportsCamo( entity player )
{
	asset modelName = player.GetModelName()
	if ( PILOT_MODELS_SUPPORTS_CAMO.contains( modelName ) )
	 	return true

	return false
}

void function RainbowWeaponSkin( entity weaponOwner )
{
	weaponOwner.Signal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "OnDestroy" )
	weaponOwner.EndSignal( "OnDeath" )
	weaponOwner.EndSignal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "EndRainbowWeapon" )

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		foreach( entity weapon in weaponOwner.GetMainWeapons() )
		{
			weapon.SetSkin( 1 )
			weapon.SetCamo( camoIndexArray[index] )
		}
	}
}

void function RGY_BatterySkin( entity battery )
{
	if( battery.GetClassName() != "item_titan_battery" )
		return

	battery.Signal( "StartRGYBattery" )
	battery.EndSignal( "OnDestroy" )
	battery.EndSignal( "StartRGYBattery" )
	battery.EndSignal( "EndRGYBattery" )

	int index = 0
	while( true )
	{
		//print( "setting battery skin: " + string( index ) )
		WaitFrame()
		battery.SetSkin( index )
		Battery_StopFX( battery )
		if( index == 2 )
			index = 0
		else
			index++
	}
}

void function HoloFlash_Loop( entity player, float interval = 1.0 )
{
	player.Signal( "StartHoloFlash" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartHoloFlash" )
	player.EndSignal( "EndHoloFlash" )

	while( true )
	{
		wait interval

		HoloFlash( player )
	}
}

void function HoloFlash( entity player )
{
	int attachIndex = player.LookupAttachment( "CHESTFOCUS" )
	//StartParticleEffectOnEntity( player, GetParticleSystemIndex( GHOST_TRAIL_EFFECT ), FX_PATTACH_POINT_FOLLOW, attachIndex )
	entity flashFX = StartParticleEffectOnEntity_ReturnEntity( player, GetParticleSystemIndex( GHOST_FLASH_EFFECT ), FX_PATTACH_POINT, attachIndex )
	flashFX.SetOwner( player )
	SetTeam( flashFX, player.GetTeam() )
	flashFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // not owner only
}

void function PlayerPulseBladeModel_HideBodyAndLegs( entity player )
{
	player.SetModel( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = player.FindBodyGroup( "body" )
	player.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = player.FindBodyGroup( "legs" )
	player.SetBodygroup( bodyGroupIndex, 0 )
}

// create a pulseblade pilot's head
entity function CreatePulseBladeHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

// create a headshot head! this is not a model that can freely scale
entity function CreateWoundedHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )
	bodyGroupIndex = prop.FindBodyGroup( "head" )
	prop.SetBodygroup( bodyGroupIndex, 1 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

void function BindPulseBladeHeadToPlayer( entity player )
{
	entity head = CreatePulseBladeHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
	
	//head.SetSkin( 2 )
	//head.SetCamo( 14 )
}

void function BindeWoundedHeadToPlayer( entity player )
{
	entity head = CreateWoundedHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
}

void function TrackPlayerDeathForHeadProp( entity player, entity head )
{
	player.EndSignal( "OnDestroy" )

	WaitFrame() // since altpilot resets player's visibility everytime they respawn or changeloadout
	player.kv.VisibilityFlags = 0 // hide player

	OnThreadEnd(
		function():( head )
		{
			if ( IsValid( head ) )
				head.Destroy()
		}
	)

	player.WaitSignal( "OnDeath" )
	player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE // restore player visibility!
}

/* 
	index
	studio "gib_lump_LOD0.smd"
	studio "gib_small_02_LOD0.smd"
	studio "gib_brain_LOD0.smd"
	studio "gib_muscle_LOD0.smd"
	studio "gib_small_01_LOD0.smd"
*/
entity function CreateHumanGib( vector origin, vector angles, float scale = 1.0, int styleIndex = -1 )
{
	entity prop_physics = CreateEntity( "prop_physics" )
	prop_physics.SetValueForModelKey( $"models/gibs/human_gibs.mdl" )
	prop_physics.SetModel( $"models/gibs/human_gibs.mdl" ) // required to make finding bodygroup work
	prop_physics.kv.spawnflags = 4 // 4 = SF_PHYSPROP_DEBRIS
	prop_physics.kv.fadedist = 2000
	prop_physics.kv.renderamt = 255
	prop_physics.kv.rendercolor = "255 255 255"
	prop_physics.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS

	// funny things
	int bodyGroupIndex = prop_physics.FindBodyGroup( "gibs" )
	int maxBodyGroup = prop_physics.GetBodyGroupModelCount( bodyGroupIndex )
	int bodygroupValue
	if ( styleIndex == -1 ) // not setting...
		bodygroupValue = RandomInt( maxBodyGroup ) // get a random one
	else
		bodygroupValue = styleIndex
	prop_physics.SetBodygroup( bodyGroupIndex, bodygroupValue )

	prop_physics.kv.modelscale = scale

	prop_physics.SetOrigin( origin )
	prop_physics.SetAngles( angles )
	DispatchSpawn( prop_physics )
	prop_physics.SetModel( $"models/gibs/human_gibs.mdl" )
	thread DelayedPinkmistGib( prop_physics )

	return prop_physics
}

void function DelayedPinkmistGib( entity gib )
{
	gib.EndSignal( "OnDestroy" )

	wait 1
	gib.Dissolve( ENTITY_DISSOLVE_PINKMIST, < 0, 0, 0 >, 0 )
}

void function BecomeApexLegend( entity player, string model = "ash" ) // ash, blisk, jack, sarah
{
	TakeAllWeapons( player )

	player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, ["wraith_phase"] )
	player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_ORDNANCE, ["octane_stim"] )
	player.GiveOffhandWeapon( "mp_weapon_hard_cover", OFFHAND_ANTIRODEO, ["deployable_dome_shield"] )
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, ["pushback_melee"] )
	player.GiveWeapon( "mp_weapon_gunship_missile", ["pilot_emptyhanded"] )
	player.SetActiveWeaponByName( "mp_weapon_gunship_missile" )
	player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), ["disable_doublejump","only_wallclimb", "pas_wallhang"] )

	asset modelToUse
	if ( model == "ash" )
		modelToUse = $"models/Humans/heroes/imc_hero_ash.mdl"
	else if ( model == "blisk" )
		modelToUse = $"models/Humans/heroes/imc_hero_blisk.mdl"
	else if ( model == "jack" )
		modelToUse = $"models/humans/heroes/mlt_hero_jack.mdl"
	else if ( model == "sarah" )
		modelToUse = $"models/Humans/heroes/mlt_hero_sarah.mdl"

	player.SetModel( modelToUse )
	GivePassive( player, ePassives.PAS_STEALTH_MOVEMENT ) // hide jetpack flame

	thread DisableBoostBar( player )
}

void function DisableBoostBar( entity player )
{
	WaitFrame()
	if( IsValid( player ) )
		PlayerEarnMeter_SetMode( player, eEarnMeterMode.DISABLED )
}

entity function CreateRainbowDomeShield( vector origin, vector angles, float duration = -1, bool notSolid = false )
{
	entity bubbleShield = CreateEntity( "prop_dynamic" )
	bubbleShield.SetValueForModelKey( $"models/fx/xo_shield.mdl" )
	if ( !notSolid )
		bubbleShield.kv.solid = SOLID_VPHYSICS
    bubbleShield.kv.rendercolor = "81 130 151"
    bubbleShield.kv.contents = (int(bubbleShield.kv.contents) | CONTENTS_NOGRAPPLE)
	bubbleShield.SetOrigin( origin )
	bubbleShield.SetAngles( angles )
	bubbleShield.Hide()

     // Blocks bullets, projectiles but not players and not AI
	bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS
	bubbleShield.SetBlocksRadiusDamage( true )
	DispatchSpawn( bubbleShield )
    array<entity> bubbleShieldFXs
	vector coloredFXOrigin = bubbleShield.GetOrigin()
	table bubbleShieldDotS = expect table( bubbleShield.s )

	//Create friendly and enemy colored particle systems
	entity rainbowColoredFX = StartParticleEffectInWorld_ReturnEntity( BUBBLE_SHIELD_FX_PARTICLE_SYSTEM_INDEX, coloredFXOrigin, angles )
	thread RainbowColorThink( rainbowColoredFX )
	bubbleShieldFXs.append( rainbowColoredFX )

    EmitSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
    thread CleanupBubbleShield( bubbleShield, bubbleShieldFXs, duration )

	return bubbleShield
}

void function RainbowColorThink( entity fx )
{
	fx.EndSignal( "OnDestroy" )

	vector rgb = < 255, 0, 0 > // start with red
	float segment = 25.5
	while ( true )
	{
		WaitFrame()

		// to < 255, 255, 0 >
		if ( rgb.x == 255 && rgb.y < 255 && rgb.z == 0 )
			rgb.y = min( 255, rgb.y + segment )
		// to < 0, 255, 0 >
		else if ( rgb.x > 0 && rgb.y == 255 && rgb.z == 0 )
			rgb.x = max( 0, rgb.x - segment )
		// to < 0, 255, 255 >
		else if ( rgb.x == 0 && rgb.y == 255 && rgb.z < 255 )
			rgb.z = min( 255, rgb.z + segment )
		// to < 0, 0, 255 >
		else if ( rgb.x == 0 && rgb.y > 0 && rgb.z == 255 )
			rgb.y = max( 0, rgb.y - segment )
		// to < 255, 0, 255 >
		else if ( rgb.x < 255 && rgb.y == 0 && rgb.z == 255 )
			rgb.x = min( 255, rgb.x + segment )
		// to < 255, 0, 0 >, a whole loop done
		else if ( rgb.x == 255 && rgb.y == 0 && rgb.z > 0 )
			rgb.z = max( 0, rgb.z - segment )

		//print( rgb )
		EffectSetControlPointVector( fx, 1, rgb )
	}
}

void function CleanupBubbleShield( entity bubbleShield, array<entity> bubbleShieldFXs, float fadeTime )
{
	bubbleShield.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function () : ( bubbleShield, bubbleShieldFXs )
		{
			if ( IsValid_ThisFrame( bubbleShield ) )
			{
				StopSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
				EmitSoundOnEntity( bubbleShield, "BubbleShield_End" )
				DestroyBubbleShield( bubbleShield )
			}

			foreach ( fx in bubbleShieldFXs )
			{
				if ( IsValid_ThisFrame( fx ) )
				{
					EffectStop( fx )
				}
			}
		}
	)

	if ( fadeTime == -1 ) // default
		WaitForever()
	else if ( fadeTime > 0 )
		wait fadeTime
}

// test nuke thing
void function NukeIncomingEffectForPlayer( entity player, float timeBeforeNuke = 2.5 )
{
	player.EndSignal( "OnDestroy" )
	player.Signal( "NukeIncomingEffect" )
	player.EndSignal( "NukeIncomingEffect" )
	float bloomScale = 1.0
	float sunScale = -1.0

	EmitSoundOnEntityOnlyToPlayer( player, player, "titan_nuclear_death_alarm" )
	wait 1.2
	
	float endTime = Time() + timeBeforeNuke + 0.6
	EmitSoundOnEntityOnlyToPlayer( player, player, "titan_nuclear_death_charge" )
	
	thread DelayedDoNukeSound( player, timeBeforeNuke )
	while ( Time() < endTime )
	{
		Remote_CallFunction_Replay( player, "ServerCallback_ScreenShake", 5, 10, 0.5 )
		Remote_CallFunction_NonReplay( player, "ServerCallback_SetMapSettings", bloomScale, false, 1.0, 1.0, 1.0, 0, 0, sunScale, 1.0 )
		bloomScale += 0.2
		sunScale -= 0.1
		WaitFrame()
	}
}

void function DelayedDoNukeSound( entity player, float timeBeforeNuke )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "NukeIncomingEffect" )
	wait timeBeforeNuke
	ScreenFade( player, 255, 255, 255, 255, 0.5, 10, FFADE_OUT | FFADE_PURGE )
	wait 0.9
	Remote_CallFunction_NonReplay( player, "ServerCallback_ResetMapSettings" )
	EmitSoundOnEntityOnlyToPlayer( player, player, "titan_nuclear_death_explode" )
	wait 10
}

// turrets
entity function CreateRocketTurret( int team, vector origin, vector angles )
{
	entity turret = CreateNPC( "npc_turret_sentry", team, origin, angles )
	turret.StartDeployed()
	SetSpawnOption_AISettings( turret, "npc_turret_sentry_plasma" )
	SetSpawnOption_Weapon( turret, "mp_turretweapon_blaster" )
	DispatchSpawn( turret )
	turret.SetTitle( "#WPN_BLASTER_TURRET" )
	turret.SetModel( ROCKET_TURRET_MODEL )
	//turret.TakeActiveWeapon()
	//turret.GiveWeapon( "mp_turretweapon_blaster" )
	//turret.SetActiveWeaponByName( "mp_turretweapon_blaster" )

	return turret
}

/* // turret settings
	"droppod_fireteam_turret"
	"PROTO_at_turret"		// have special pov
	"redeye_turret"
	"redeye_turret_ai"
	"sat_strike_turret"		// cannot change direction
	"turret_imc_lrg"
*/

/* // turret models
	SENTRY_TURRET_MODEL and PLASMA_TURRET_MODEL(same)
	ROCKET_TURRET_MODEL
	HITSCAN_TURRET_MODEL
*/

entity function CreateRemoteTurret( vector origin, vector angles, vector panelOrigin, vector panelAngles, asset turretModel, string turretWeapon )
{
	RemoteTurretSettings info

	info.turretOrigin = origin
	info.turretAngles = angles
	info.panelOrigin = panelOrigin
	info.panelAngles = panelAngles

	info.turretSettingsName		= "PROTO_at_turret"
	info.weaponName				= turretWeapon
	info.turretModel			= turretModel
	info.panelModel				= CONTROL_PANEL_MODEL

	info.viewClampEnabled		= true
	info.viewClampRangeYaw		= 120
	info.viewClampRangePitch	= 120
	info.viewStartPitch			= 0

	entity turret = CreateRemoteTurretAndControlPanel( info )
	return turret
}